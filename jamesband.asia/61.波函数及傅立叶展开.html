<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‚…é‡Œå¶å˜æ¢å±€åŸŸåŒ–åŸç†ä¸ä¸ç¡®å®šæ€§å…³ç³»çš„æ·±åº¦è§£æ</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e);
            color: #fff;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #00d4ff;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #00d4ff;
        }

        .subtitle {
            text-align: center;
            color: #ccc;
            font-size: 1.3em;
            margin-bottom: 30px;
            font-style: italic;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .visualization-panel {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00d4ff;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.3);
        }

        .panel-title {
            text-align: center;
            color: #00d4ff;
            font-size: 1.4em;
            margin-bottom: 15px;
            font-weight: bold;
        }

        canvas {
            width: 100%;
            height: 350px;
            background: #000;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .controls-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #00d4ff;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            background: rgba(0, 212, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .control-group h3 {
            color: #00d4ff;
            margin: 0 0 15px 0;
            font-size: 1.2em;
        }

        .control-item {
            display: flex;
            align-items: center;
            margin: 10px 0;
            gap: 15px;
        }

        label {
            color: #fff;
            min-width: 120px;
            font-weight: 500;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            background: linear-gradient(to right, #00d4ff, #0099cc);
            outline: none;
            border-radius: 3px;
        }

        input[type="range"]::-webkit-slider-thumb {
            width: 20px;
            height: 20px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
            -webkit-appearance: none;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .value-display {
            color: #00d4ff;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 5px;
            min-width: 80px;
            text-align: center;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        select {
            background: #1a1a2e;
            color: #fff;
            border: 1px solid #00d4ff;
            border-radius: 5px;
            padding: 8px;
            font-size: 14px;
        }

        button {
            background: linear-gradient(45deg, #00d4ff, #0099cc);
            color: #fff;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
            margin: 5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.5);
        }

        .uncertainty-display {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #ff6b6b;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .uncertainty-display h3 {
            color: #ff6b6b;
            margin: 0 0 15px 0;
            font-size: 1.5em;
        }

        .uncertainty-values {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .uncertainty-item {
            background: rgba(255, 107, 107, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 107, 107, 0.3);
        }

        .uncertainty-label {
            color: #ccc;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .uncertainty-value {
            color: #ff6b6b;
            font-size: 1.4em;
            font-weight: bold;
        }

        .formula-display {
            background: rgba(0, 0, 0, 0.5);
            border-left: 4px solid #00d4ff;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            color: #fff;
        }

        .theory-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
        }

        .theory-section h3 {
            color: #ffd700;
            font-size: 1.4em;
            margin-bottom: 15px;
        }

        .theory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .insight-box {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
        }

        .insight-box h4 {
            color: #ffd700;
            margin: 0 0 10px 0;
        }

        .warning-box {
            background: rgba(255, 107, 107, 0.1);
            border: 2px solid #ff6b6b;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .warning-box.success {
            background: rgba(0, 255, 0, 0.1);
            border-color: #00ff00;
        }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .control-item {
                flex-direction: column;
                align-items: stretch;
            }
            
            label {
                min-width: auto;
                margin-bottom: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸŒŠ å‚…é‡Œå¶å˜æ¢å±€åŸŸåŒ–åŸç† âš›ï¸</h1>
        <p class="subtitle">æ·±åº¦è§£æï¼šå‡½æ•°å±€åŸŸåŒ– â†” å‚…é‡Œå¶å˜æ¢å±•å®½ â†” ä¸ç¡®å®šæ€§åŸç†</p>

        <div class="main-grid">
            <div class="visualization-panel">
                <div class="panel-title">ğŸ¯ ä½ç½®ç©ºé—´ f(x)</div>
                <canvas id="positionCanvas"></canvas>
            </div>
            <div class="visualization-panel">
                <div class="panel-title">ğŸ“Š é¢‘ç‡ç©ºé—´ F(k) = FT[f(x)]</div>
                <canvas id="frequencyCanvas"></canvas>
            </div>
        </div>

        <div class="uncertainty-display">
            <h3>ğŸ”¬ æµ·æ£®å ¡ä¸ç¡®å®šæ€§åŸç†éªŒè¯</h3>
            <div class="uncertainty-values">
                <div class="uncertainty-item">
                    <div class="uncertainty-label">ä½ç½®ä¸ç¡®å®šåº¦</div>
                    <div class="uncertainty-value" id="deltaX">--</div>
                </div>
                <div class="uncertainty-item">
                    <div class="uncertainty-label">åŠ¨é‡ä¸ç¡®å®šåº¦</div>
                    <div class="uncertainty-value" id="deltaP">--</div>
                </div>
                <div class="uncertainty-item">
                    <div class="uncertainty-label">ä¸ç¡®å®šæ€§ä¹˜ç§¯</div>
                    <div class="uncertainty-value" id="uncertaintyProduct">--</div>
                </div>
                <div class="uncertainty-item">
                    <div class="uncertainty-label">â„/2 ä¸‹é™</div>
                    <div class="uncertainty-value">0.5273</div>
                </div>
            </div>
            <div class="warning-box" id="uncertaintyStatus">
                æ­£åœ¨è®¡ç®—ä¸ç¡®å®šæ€§å…³ç³»...
            </div>
        </div>

        <div class="controls-section">
            <h3 style="text-align: center; color: #00d4ff; margin-bottom: 20px;">ğŸ›ï¸ äº¤äº’å¼å‚æ•°æ§åˆ¶</h3>
            
            <div class="controls-grid">
                <div class="control-group">
                    <h3>ğŸ“ æ³¢åŒ…å½¢çŠ¶ä¸å‚æ•°</h3>
                    <div class="control-item">
                        <label>æ³¢åŒ…ç±»å‹:</label>
                        <select id="wavePacketType">
                            <option value="gaussian">é«˜æ–¯æ³¢åŒ…</option>
                            <option value="rectangular">çŸ©å½¢çª—</option>
                            <option value="triangular">ä¸‰è§’çª—</option>
                            <option value="cosine">ä½™å¼¦çª—</option>
                            <option value="exponential">æŒ‡æ•°è¡°å‡</option>
                        </select>
                    </div>
                    <div class="control-item">
                        <label>å±€åŸŸåŒ–ç¨‹åº¦:</label>
                        <input type="range" id="localizationWidth" min="0.5" max="10" value="2" step="0.1">
                        <div class="value-display" id="widthValue">2.0</div>
                    </div>
                    <div class="control-item">
                        <label>ä¸­å¿ƒé¢‘ç‡:</label>
                        <input type="range" id="carrierFrequency" min="0" max="20" value="5" step="0.5">
                        <div class="value-display" id="freqValue">5.0</div>
                    </div>
                </div>

                <div class="control-group">
                    <h3>ğŸ”¬ æ•°å€¼è®¡ç®—å‚æ•°</h3>
                    <div class="control-item">
                        <label>é‡‡æ ·ç‚¹æ•°:</label>
                        <input type="range" id="samplePoints" min="256" max="2048" value="1024" step="256">
                        <div class="value-display" id="pointsValue">1024</div>
                    </div>
                    <div class="control-item">
                        <label>è®¡ç®—ç²¾åº¦:</label>
                        <select id="precision">
                            <option value="low">ä½ç²¾åº¦(å¿«é€Ÿ)</option>
                            <option value="medium" selected>ä¸­ç²¾åº¦</option>
                            <option value="high">é«˜ç²¾åº¦(æ…¢é€Ÿ)</option>
                        </select>
                    </div>
                    <div class="control-item">
                        <label>æ˜¾ç¤ºèŒƒå›´:</label>
                        <input type="range" id="displayRange" min="5" max="50" value="20" step="5">
                        <div class="value-display" id="rangeValue">Â±20</div>
                    </div>
                </div>

                <div class="control-group">
                    <h3>ğŸ¨ å¯è§†åŒ–é€‰é¡¹</h3>
                    <div class="control-item">
                        <button onclick="toggleRealImaginary()">åˆ‡æ¢å®éƒ¨/è™šéƒ¨æ˜¾ç¤º</button>
                        <button onclick="toggleLogScale()">å¯¹æ•°åæ ‡</button>
                    </div>
                    <div class="control-item">
                        <button onclick="addComparison()">æ·»åŠ å¯¹æ¯”æ³¢åŒ…</button>
                        <button onclick="clearComparisons()">æ¸…é™¤å¯¹æ¯”</button>
                    </div>
                    <div class="control-item">
                        <button onclick="exportData()">å¯¼å‡ºæ•°æ®</button>
                        <button onclick="resetToDefaults()">æ¢å¤é»˜è®¤</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="theory-section">
            <h3>ğŸ§  æ·±å±‚ç†è®ºè§£æ</h3>
            <div class="theory-grid">
                <div class="insight-box">
                    <h4>ğŸ” æ•°å­¦æœ¬è´¨</h4>
                    <p>å‚…é‡Œå¶å˜æ¢æ˜¯ä¸€ç§æ•°å­¦å˜æ¢ï¼Œå°†å‡½æ•°ä»ä¸€ä¸ªåŸŸï¼ˆé€šå¸¸æ˜¯æ—¶é—´æˆ–ä½ç½®ï¼‰è½¬æ¢åˆ°å¦ä¸€ä¸ªåŸŸï¼ˆé¢‘ç‡æˆ–åŠ¨é‡ï¼‰ã€‚å…³é”®æ€§è´¨ï¼š</p>
                    <div class="formula-display">
                        F(k) = âˆ« f(x) e^(-ikx) dx<br>
                        f(x) = (1/2Ï€) âˆ« F(k) e^(ikx) dk
                    </div>
                    <p><strong>å±€åŸŸåŒ–åŸç†ï¼š</strong>ä¸€ä¸ªå‡½æ•°åœ¨æŸä¸ªåŸŸå†…è¶Šå±€åŸŸåŒ–ï¼ˆé›†ä¸­ï¼‰ï¼Œå®ƒåœ¨å‚…é‡Œå¶å˜æ¢åŸŸå†…å¿…ç„¶è¶Šå±•å®½ï¼ˆåˆ†æ•£ï¼‰ã€‚</p>
                </div>

                <div class="insight-box">
                    <h4>âš›ï¸ é‡å­åŠ›å­¦è”ç³»</h4>
                    <p>åœ¨é‡å­åŠ›å­¦ä¸­ï¼Œå¾·å¸ƒç½—æ„å…³ç³»å»ºç«‹äº†ä½ç½®-åŠ¨é‡çš„å¯¹åº”ï¼š</p>
                    <div class="formula-display">
                        p = â„k ï¼ˆåŠ¨é‡ = çº¦åŒ–æ™®æœ—å…‹å¸¸æ•° Ã— æ³¢æ•°ï¼‰
                    </div>
                    <p>å› æ­¤ï¼Œä½ç½®æ³¢å‡½æ•°Ïˆ(x)çš„å‚…é‡Œå¶å˜æ¢ç›´æ¥ç»™å‡ºåŠ¨é‡æ³¢å‡½æ•°Ï†(p)ã€‚</p>
                </div>

                <div class="insight-box">
                    <h4>ğŸ“ ä¸ç¡®å®šåº¦è®¡ç®—</h4>
                    <p>æ ‡å‡†å·®å®šä¹‰çš„ä¸ç¡®å®šåº¦ï¼š</p>
                    <div class="formula-display">
                        Î”x = âˆš(âŸ¨xÂ²âŸ© - âŸ¨xâŸ©Â²)<br>
                        Î”p = âˆš(âŸ¨pÂ²âŸ© - âŸ¨pâŸ©Â²)<br>
                        Î”xÂ·Î”p â‰¥ â„/2
                    </div>
                    <p>è¿™ä¸æ˜¯æµ‹é‡é™åˆ¶ï¼Œè€Œæ˜¯æ³¢åŠ¨æ€§çš„æ ¹æœ¬ç‰¹å¾ï¼</p>
                </div>

                <div class="insight-box">
                    <h4>ğŸŒŸ ç‰©ç†ç›´è§‰</h4>
                    <p><strong>æƒ³è±¡ä¸€ä¸ª"æ³¢åŒ…å‹ç¼©å™¨"ï¼š</strong></p>
                    <ul>
                        <li>ğŸ”§ å½“ä½ å‹ç¼©æ³¢åŒ…çš„ä½ç½®ï¼ˆè®©å®ƒæ›´å±€åŸŸåŒ–ï¼‰</li>
                        <li>ğŸ“ˆ å®ƒçš„é¢‘ç‡æˆåˆ†å¿…ç„¶å˜å¾—æ›´ä¸°å¯Œï¼ˆæ›´å±•å®½ï¼‰</li>
                        <li>âš–ï¸ è¿™æ˜¯è‡ªç„¶ç•Œçš„å®ˆæ’å¾‹ï¼Œæ²¡æœ‰ä»»ä½•æŠ€æœ¯èƒ½è¿å</li>
                        <li>ğŸ’ é«˜æ–¯æ³¢åŒ…å®ç°äº†ç†è®ºæœ€å°å€¼ï¼šÎ”xÂ·Î”p = â„/2</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let positionCanvas, frequencyCanvas;
        let positionCtx, frequencyCtx;
        let currentWavePacket = null;
        let comparisonWavePackets = [];
        let showRealPart = true;
        let useLogScale = false;
        let animationId = null;

        // ç‰©ç†å¸¸æ•°
        const HBAR = 1.054571817e-34; // å®é™…çš„çº¦åŒ–æ™®æœ—å…‹å¸¸æ•°
        const HBAR_NORMALIZED = 1.0;   // å½’ä¸€åŒ–å•ä½

        // åˆå§‹åŒ–
        window.onload = function() {
            initializeCanvases();
            setupEventListeners();
            calculateAndDraw();
        };

        function initializeCanvases() {
            positionCanvas = document.getElementById('positionCanvas');
            frequencyCanvas = document.getElementById('frequencyCanvas');
            positionCtx = positionCanvas.getContext('2d');
            frequencyCtx = frequencyCanvas.getContext('2d');

            // è®¾ç½®ç”»å¸ƒå°ºå¯¸
            function resizeCanvases() {
                const rect = positionCanvas.parentElement.getBoundingClientRect();
                const width = rect.width - 40;
                const height = 350;

                positionCanvas.width = width;
                positionCanvas.height = height;
                frequencyCanvas.width = width;
                frequencyCanvas.height = height;

                calculateAndDraw();
            }

            resizeCanvases();
            window.addEventListener('resize', resizeCanvases);
        }

        function setupEventListeners() {
            // å‚æ•°æ§åˆ¶
            document.getElementById('localizationWidth').addEventListener('input', updateParameters);
            document.getElementById('carrierFrequency').addEventListener('input', updateParameters);
            document.getElementById('wavePacketType').addEventListener('change', updateParameters);
            document.getElementById('samplePoints').addEventListener('input', updateParameters);
            document.getElementById('displayRange').addEventListener('input', updateParameters);
        }

        function updateParameters() {
            // æ›´æ–°æ˜¾ç¤ºå€¼
            const width = parseFloat(document.getElementById('localizationWidth').value);
            const freq = parseFloat(document.getElementById('carrierFrequency').value);
            const points = parseInt(document.getElementById('samplePoints').value);
            const range = parseInt(document.getElementById('displayRange').value);

            document.getElementById('widthValue').textContent = width.toFixed(1);
            document.getElementById('freqValue').textContent = freq.toFixed(1);
            document.getElementById('pointsValue').textContent = points;
            document.getElementById('rangeValue').textContent = `Â±${range}`;

            calculateAndDraw();
        }

        // æ³¢åŒ…ç”Ÿæˆå‡½æ•°
        class WavePacket {
            constructor(type, width, centerFreq, points = 1024, range = 20) {
                this.type = type;
                this.width = width;
                this.centerFreq = centerFreq;
                this.points = points;
                this.range = range;
                this.dx = 2 * range / points;
                this.dk = 2 * Math.PI / (2 * range);

                this.generatePositionData();
                this.computeFourierTransform();
                this.calculateUncertainties();
            }

            generatePositionData() {
                this.x = [];
                this.positionData = [];

                for (let i = 0; i < this.points; i++) {
                    const x = -this.range + i * this.dx;
                    this.x.push(x);

                    let envelope, phase;
                    phase = this.centerFreq * x;

                    switch (this.type) {
                        case 'gaussian':
                            envelope = Math.exp(-0.5 * Math.pow(x / this.width, 2));
                            break;
                        case 'rectangular':
                            envelope = Math.abs(x) <= this.width ? 1 : 0;
                            break;
                        case 'triangular':
                            envelope = Math.abs(x) <= this.width ? 1 - Math.abs(x) / this.width : 0;
                            break;
                        case 'cosine':
                            envelope = Math.abs(x) <= this.width ? Math.cos(Math.PI * x / (2 * this.width)) : 0;
                            break;
                        case 'exponential':
                            envelope = Math.exp(-Math.abs(x) / this.width);
                            break;
                        default:
                            envelope = Math.exp(-0.5 * Math.pow(x / this.width, 2));
                    }

                    this.positionData.push({
                        real: envelope * Math.cos(phase),
                        imag: envelope * Math.sin(phase),
                        magnitude: envelope
                    });
                }

                // å½’ä¸€åŒ–
                this.normalizePositionData();
            }

            normalizePositionData() {
                const totalProb = this.positionData.reduce((sum, data) => 
                    sum + (data.real * data.real + data.imag * data.imag), 0) * this.dx;
                
                const norm = Math.sqrt(totalProb);
                if (norm > 0) {
                    this.positionData.forEach(data => {
                        data.real /= norm;
                        data.imag /= norm;
                        data.magnitude /= norm;
                    });
                }
            }

            computeFourierTransform() {
                this.k = [];
                this.frequencyData = [];

                const kMax = Math.PI / this.dx;
                const dk = 2 * kMax / this.points;

                for (let i = 0; i < this.points; i++) {
                    const k = -kMax + i * dk;
                    this.k.push(k);

                    let real = 0, imag = 0;

                    // æ•°å€¼å‚…é‡Œå¶å˜æ¢
                    for (let j = 0; j < this.points; j++) {
                        const x = this.x[j];
                        const phase = -k * x;
                        const cosPhase = Math.cos(phase);
                        const sinPhase = Math.sin(phase);

                        real += (this.positionData[j].real * cosPhase - this.positionData[j].imag * sinPhase) * this.dx;
                        imag += (this.positionData[j].real * sinPhase + this.positionData[j].imag * cosPhase) * this.dx;
                    }

                    this.frequencyData.push({
                        real: real,
                        imag: imag,
                        magnitude: Math.sqrt(real * real + imag * imag)
                    });
                }
            }

            calculateUncertainties() {
                // è®¡ç®—ä½ç½®çš„æœŸæœ›å€¼å’Œä¸ç¡®å®šåº¦
                let xMean = 0, x2Mean = 0, totalProb = 0;

                for (let i = 0; i < this.points; i++) {
                    const prob = this.positionData[i].real * this.positionData[i].real + 
                               this.positionData[i].imag * this.positionData[i].imag;
                    xMean += this.x[i] * prob * this.dx;
                    x2Mean += this.x[i] * this.x[i] * prob * this.dx;
                    totalProb += prob * this.dx;
                }

                xMean /= totalProb;
                x2Mean /= totalProb;
                this.deltaX = Math.sqrt(Math.max(0, x2Mean - xMean * xMean));

                // è®¡ç®—åŠ¨é‡çš„æœŸæœ›å€¼å’Œä¸ç¡®å®šåº¦
                let pMean = 0, p2Mean = 0, totalProbP = 0;

                for (let i = 0; i < this.points; i++) {
                    const prob = this.frequencyData[i].real * this.frequencyData[i].real + 
                               this.frequencyData[i].imag * this.frequencyData[i].imag;
                    const p = HBAR_NORMALIZED * this.k[i]; // p = â„k
                    pMean += p * prob;
                    p2Mean += p * p * prob;
                    totalProbP += prob;
                }

                if (totalProbP > 0) {
                    pMean /= totalProbP;
                    p2Mean /= totalProbP;
                    this.deltaP = Math.sqrt(Math.max(0, p2Mean - pMean * pMean));
                } else {
                    this.deltaP = 0;
                }

                this.uncertaintyProduct = this.deltaX * this.deltaP;
            }
        }

        function calculateAndDraw() {
            const type = document.getElementById('wavePacketType').value;
            const width = parseFloat(document.getElementById('localizationWidth').value);
            const freq = parseFloat(document.getElementById('carrierFrequency').value);
            const points = parseInt(document.getElementById('samplePoints').value);
            const range = parseInt(document.getElementById('displayRange').value);

            // ç”Ÿæˆå½“å‰æ³¢åŒ…
            currentWavePacket = new WavePacket(type, width, freq, points, range);

            // ç»˜åˆ¶å›¾å½¢
            drawPositionSpace();
            drawFrequencySpace();
            updateUncertaintyDisplay();
        }

        function drawPositionSpace() {
            const ctx = positionCtx;
            const canvas = positionCanvas;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!currentWavePacket) return;

            // è®¾ç½®åæ ‡ç³»
            const padding = 60;
            const plotWidth = canvas.width - 2 * padding;
            const plotHeight = canvas.height - 2 * padding;

            // ç»˜åˆ¶åæ ‡è½´
            drawAxes(ctx, padding, plotWidth, plotHeight, 'x', '|Ïˆ(x)|Â², Re[Ïˆ(x)]');

            // ç»˜åˆ¶æ³¢å‡½æ•°
            drawWaveFunction(ctx, currentWavePacket, padding, plotWidth, plotHeight, true);

            // ç»˜åˆ¶å¯¹æ¯”æ³¢åŒ…
            comparisonWavePackets.forEach((wp, index) => {
                drawWaveFunction(ctx, wp, padding, plotWidth, plotHeight, true, `hsl(${120 + index * 60}, 70%, 60%)`);
            });
        }

        function drawFrequencySpace() {
            const ctx = frequencyCtx;
            const canvas = frequencyCanvas;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!currentWavePacket) return;

            // è®¾ç½®åæ ‡ç³»
            const padding = 60;
            const plotWidth = canvas.width - 2 * padding;
            const plotHeight = canvas.height - 2 * padding;

            // ç»˜åˆ¶åæ ‡è½´
            drawAxes(ctx, padding, plotWidth, plotHeight, 'k', '|F(k)|Â², Re[F(k)]');

            // ç»˜åˆ¶å‚…é‡Œå¶å˜æ¢
            drawWaveFunction(ctx, currentWavePacket, padding, plotWidth, plotHeight, false);

            // ç»˜åˆ¶å¯¹æ¯”æ³¢åŒ…
            comparisonWavePackets.forEach((wp, index) => {
                drawWaveFunction(ctx, wp, padding, plotWidth, plotHeight, false, `hsl(${120 + index * 60}, 70%, 60%)`);
            });
        }

        function drawAxes(ctx, padding, plotWidth, plotHeight, xLabel, yLabel) {
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;

            // Xè½´
            ctx.beginPath();
            ctx.moveTo(padding, padding + plotHeight);
            ctx.lineTo(padding + plotWidth, padding + plotHeight);
            ctx.stroke();

            // Yè½´
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + plotHeight);
            ctx.stroke();

            // æ ‡ç­¾
            ctx.fillStyle = '#fff';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(xLabel, padding + plotWidth / 2, padding + plotHeight + 40);

            ctx.save();
            ctx.translate(20, padding + plotHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(yLabel, 0, 0);
            ctx.restore();

            // ç½‘æ ¼çº¿
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 0.5;
            for (let i = 1; i < 10; i++) {
                const x = padding + i * plotWidth / 10;
                const y = padding + i * plotHeight / 10;

                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, padding + plotHeight);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + plotWidth, y);
                ctx.stroke();
            }
        }

        function drawWaveFunction(ctx, wavePacket, padding, plotWidth, plotHeight, isPosition, color = '#00d4ff') {
            const data = isPosition ? wavePacket.positionData : wavePacket.frequencyData;
            const xData = isPosition ? wavePacket.x : wavePacket.k;

            if (!data || data.length === 0) return;

            // æ‰¾åˆ°æ•°æ®èŒƒå›´
            const xMin = Math.min(...xData);
            const xMax = Math.max(...xData);

            let yMax = 0;
            if (showRealPart) {
                yMax = Math.max(...data.map(d => Math.abs(d.real)));
            } else {
                yMax = Math.max(...data.map(d => d.magnitude * d.magnitude));
            }

            if (yMax === 0) yMax = 1;

            // ç»˜åˆ¶æ¦‚ç‡å¯†åº¦
            ctx.strokeStyle = color + '80';
            ctx.fillStyle = color + '20';
            ctx.lineWidth = 2;

            ctx.beginPath();
            let firstPoint = true;

            for (let i = 0; i < data.length; i++) {
                const x = padding + (xData[i] - xMin) / (xMax - xMin) * plotWidth;
                let y;

                if (showRealPart) {
                    y = padding + plotHeight - (data[i].real / yMax * 0.8 + 0.1) * plotHeight;
                } else {
                    const probDensity = data[i].magnitude * data[i].magnitude;
                    y = padding + plotHeight - (probDensity / (yMax * yMax) * 0.8 + 0.1) * plotHeight;
                }

                if (useLogScale && !showRealPart) {
                    const probDensity = data[i].magnitude * data[i].magnitude;
                    if (probDensity > 0) {
                        const logVal = Math.log10(probDensity / (yMax * yMax));
                        y = padding + plotHeight - (logVal + 5) / 5 * plotHeight;
                    }
                }

                if (firstPoint) {
                    ctx.moveTo(x, y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // å¡«å……åŒºåŸŸï¼ˆä»…å¯¹æ¦‚ç‡å¯†åº¦ï¼‰
            if (!showRealPart) {
                ctx.lineTo(padding + plotWidth, padding + plotHeight);
                ctx.lineTo(padding, padding + plotHeight);
                ctx.closePath();
                ctx.fill();
            }

            // ç»˜åˆ¶å®éƒ¨ï¼ˆå¦‚æœé€‰æ‹©æ˜¾ç¤ºï¼‰
            if (showRealPart) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;

                ctx.beginPath();
                for (let i = 0; i < data.length; i++) {
                    const x = padding + (xData[i] - xMin) / (xMax - xMin) * plotWidth;
                    const y = padding + plotHeight / 2 - data[i].real / yMax * plotHeight * 0.3;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }
        }

        function updateUncertaintyDisplay() {
            if (!currentWavePacket) return;

            const deltaX = currentWavePacket.deltaX;
            const deltaP = currentWavePacket.deltaP;
            const product = currentWavePacket.uncertaintyProduct;
            const minUncertainty = HBAR_NORMALIZED / 2;

            document.getElementById('deltaX').textContent = deltaX.toExponential(3);
            document.getElementById('deltaP').textContent = deltaP.toExponential(3);
            document.getElementById('uncertaintyProduct').textContent = product.toExponential(3);

            const statusDiv = document.getElementById('uncertaintyStatus');
            if (product >= minUncertainty * 0.95) { // å…è®¸æ•°å€¼è¯¯å·®
                statusDiv.textContent = `âœ… æ»¡è¶³ä¸ç¡®å®šæ€§åŸç†ï¼Î”xÂ·Î”p = ${product.toFixed(4)} â‰¥ â„/2 = ${minUncertainty.toFixed(4)}`;
                statusDiv.className = 'warning-box success';
            } else {
                statusDiv.textContent = `âŒ æ•°å€¼è®¡ç®—è¯¯å·®ï¼šÎ”xÂ·Î”p = ${product.toFixed(4)} < â„/2 = ${minUncertainty.toFixed(4)}`;
                statusDiv.className = 'warning-box';
            }

            // æ˜¾ç¤ºç›¸å¯¹äºæœ€å°å€¼çš„æ¯”ä¾‹
            const ratio = product / minUncertainty;
            statusDiv.innerHTML += `<br>ğŸ“Š è¶…å‡ºæœ€å°å€¼å€æ•°: ${ratio.toFixed(2)}x`;
        }

        // äº¤äº’åŠŸèƒ½
        function toggleRealImaginary() {
            showRealPart = !showRealPart;
            drawPositionSpace();
            drawFrequencySpace();
        }

        function toggleLogScale() {
            useLogScale = !useLogScale;
            drawPositionSpace();
            drawFrequencySpace();
        }

        function addComparison() {
            if (currentWavePacket && comparisonWavePackets.length < 3) {
                comparisonWavePackets.push(currentWavePacket);
                drawPositionSpace();
                drawFrequencySpace();
            }
        }

        function clearComparisons() {
            comparisonWavePackets = [];
            drawPositionSpace();
            drawFrequencySpace();
        }

        function exportData() {
            if (!currentWavePacket) return;

            const data = {
                parameters: {
                    type: currentWavePacket.type,
                    width: currentWavePacket.width,
                    centerFreq: currentWavePacket.centerFreq
                },
                uncertainties: {
                    deltaX: currentWavePacket.deltaX,
                    deltaP: currentWavePacket.deltaP,
                    product: currentWavePacket.uncertaintyProduct
                },
                positionData: currentWavePacket.x.map((x, i) => ({
                    x: x,
                    real: currentWavePacket.positionData[i].real,
                    imag: currentWavePacket.positionData[i].imag,
                    magnitude: currentWavePacket.positionData[i].magnitude
                })),
                frequencyData: currentWavePacket.k.map((k, i) => ({
                    k: k,
                    real: currentWavePacket.frequencyData[i].real,
                    imag: currentWavePacket.frequencyData[i].imag,
                    magnitude: currentWavePacket.frequencyData[i].magnitude
                }))
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'fourier_uncertainty_data.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function resetToDefaults() {
            document.getElementById('localizationWidth').value = 2;
            document.getElementById('carrierFrequency').value = 5;
            document.getElementById('wavePacketType').value = 'gaussian';
            document.getElementById('samplePoints').value = 1024;
            document.getElementById('displayRange').value = 20;
            
            showRealPart = true;
            useLogScale = false;
            comparisonWavePackets = [];
            
            updateParameters();
        }

        // å®æ—¶åŠ¨ç”»ï¼ˆå¯é€‰ï¼‰
        function startAnimation() {
            if (animationId) cancelAnimationFrame(animationId);
            
            let phase = 0;
            function animate() {
                phase += 0.1;
                
                // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ åŠ¨ç”»æ•ˆæœï¼Œæ¯”å¦‚æ³¢åŒ…çš„æ—¶é—´æ¼”åŒ–
                
                animationId = requestAnimationFrame(animate);
            }
            
            animate();
        }

        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
    </script>
</body>
</html>