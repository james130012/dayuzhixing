<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>张朝阳物理课：光速、普朗克常数与宇宙的秩序</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">
    <style>
        /* 基本重置和页面设置 */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Noto Sans SC', sans-serif;
            font-size: 18px; /* 基础字号，参考“三号”在屏幕上的可读性 */
            line-height: 1.8;
            background-color: #0d1117; /* GitHub 暗黑模式背景色 */
            color: #c9d1d9; /* GitHub 暗黑模式文字颜色 */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden; /* 防止水平溢出 */
        }

        /* 背景动画容器 */
        #backgroundCanvasContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            pointer-events: none; /* 允许点击穿透 */
        }

        /* 内容容器 */
        .container {
            position: relative;
            z-index: 1; /* 在背景动画之上 */
            width: 90%;
            max-width: 1000px; /* 优化阅读宽度，类似A3纸张感 */
            margin: 40px auto; /* 增加上下边距 */
            padding: 30px 40px;
            background-color: rgba(22, 27, 34, 0.9); /* GitHub 暗黑模式内容区背景 */
            border: 1px solid #30363d; /* GitHub 暗黑模式边框颜色 */
            border-radius: 12px; /* 圆角 */
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        /* 标题样式 */
        h1, h2, h3 {
            font-family: 'ZCOOL KuaiLe', cursive; /* 轻松活泼字体 */
            color: #58a6ff; /* GitHub 暗黑模式链接/标题颜色 */
            margin-bottom: 0.75em;
            text-align: center;
            letter-spacing: 1px;
        }
        h1 {
            font-size: 2.6em; /* 主标题 */
            color: #79c0ff; /* 更亮的蓝色 */
            border-bottom: 2px solid #388bfd;
            padding-bottom: 15px;
            margin-top: 0;
        }
        h2 {
            font-size: 2.0em; /* 章节标题 */
            color: #f778ba; /* 粉色系，增加活泼感 */
            margin-top: 2.2em;
        }
        h3 {
            font-size: 1.5em;
            color: #a371f7; /* 紫色系 */
            margin-top: 1.6em;
            text-align: left;
        }

        /* 段落和文本样式 */
        p, li {
            margin-bottom: 1.2em;
            text-align: justify;
            color: #adbac7; /* 柔和的文字颜色 */
        }
        ul, ol {
            padding-left: 30px;
        }

        /* 强调文字 */
        strong, .highlight {
            color: #ffa657; /* 暖黄色强调 */
            font-weight: bold;
        }
        .concept { /* 物理概念词 */
            font-weight: 500;
            color: #7ee787; /* 绿色概念词 */
            padding: 3px 7px;
            background-color: rgba(63, 185, 80, 0.15);
            border-radius: 6px;
            border: 1px solid rgba(63, 185, 80, 0.4);
            font-family: 'Noto Sans SC', sans-serif; /* 概念词使用标准字体 */
        }
        .formula {
            display: block;
            text-align: center;
            margin: 20px auto;
            padding: 15px;
            background-color: rgba(34, 39, 46, 0.8);
            border-left: 4px solid #388bfd;
            color: #c9d1d9;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.05em;
            border-radius: 4px;
            white-space: pre-wrap; /* 保证公式换行 */
        }

        /* 动画容器 */
        .animation-container {
            width: 100%;
            max-width: 580px; /* 动画区域宽度 */
            height: 360px; /* 动画区域高度 */
            margin: 25px auto;
            border: 1px solid #30363d;
            border-radius: 10px;
            overflow: hidden;
            background-color: #010409; /* 更深的动画背景 */
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: inset 0 0 12px rgba(0,0,0,0.5);
        }
        .animation-container canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
        }
        
        /* 交互按钮和控件样式 */
        .controls {
            text-align: center;
            margin-bottom: 25px;
            margin-top: 15px;
        }
        .controls button {
            padding: 10px 22px;
            font-size: 0.95em;
            font-family: 'Noto Sans SC', sans-serif;
            background-image: linear-gradient(to right, #388bfd, #58a6ff);
            color: white;
            border: none;
            border-radius: 22px; 
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            letter-spacing: 0.5px;
        }
        .controls button:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 7px 18px rgba(56, 139, 253, 0.35);
        }
        .controls button:active {
            transform: translateY(0px) scale(1);
        }
        .controls label {
            color: #8b949e; /* GitHub 暗黑模式次要文字颜色 */
            margin: 0 10px;
            font-size: 0.9em;
        }
        .controls input[type="range"] {
            vertical-align: middle;
            cursor: grab;
            width: 140px;
        }

        /* 作者信息 */
        .author-info {
            text-align: center;
            margin: 20px 0 30px 0;
            font-size: 0.95em;
            color: #8b949e;
        }
        .author-info strong {
            color: #79c0ff;
        }

        /* 页脚 */
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 25px;
            background-color: #161b22; /* 页脚背景 */
            color: #8b949e;
            width: 100%;
            font-size: 0.9em;
            border-top: 1px solid #30363d;
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            body {
                font-size: 17px; /* 移动端稍小字号 */
            }
            .container {
                width: 95%;
                padding: 20px 25px;
                margin: 20px auto;
            }
            h1 {
                font-size: 2.1em;
            }
            h2 {
                font-size: 1.7em;
            }
            h3 {
                font-size: 1.3em;
            }
            .animation-container {
                height: 310px; /* 移动端动画高度调整 */
            }
            .controls button {
                padding: 9px 18px;
                font-size: 0.85em;
            }
            .controls input[type="range"] {
                width: 120px;
            }
            .formula {
                font-size: 1em;
                padding: 10px;
            }
        }
         @media (max-width: 480px) {
            body {
                font-size: 16px;
            }
            h1 {
                font-size: 1.7em;
            }
            h2 {
                font-size: 1.4em;
            }
            h3 {
                font-size: 1.15em;
            }
            .animation-container {
                height: 270px;
            }
        }
    </style>
</head>
<body>
    <div id="backgroundCanvasContainer"></div>
    <div class="container">
        <header>
            <h1>张朝阳物理课：光速、普朗克常数与宇宙的秩序</h1>
            <div class="author-info">
                <p>解读自 <strong>张朝阳</strong> 先生的物理课程精髓</p>
                <p>（搜狐创始人、董事局主席兼CEO，麻省理工学院物理学博士）</p>
            </div>
        </header>

        <main>
            <article>
                <section id="intro-constants">
                    <h2>引言：宇宙的两大基石——光速与普朗克常数</h2>
                    <p>在物理学的浩瀚宇宙中，有两大常数如同宇宙的“定海神针”，它们不仅定义了我们所处世界的运行规则，更在微观与宏观之间架起了桥梁，深刻影响着我们对时空、能量和物质的理解。它们就是<strong class="highlight">光速 c</strong> 和<strong class="highlight">普朗克常数 h (或 ħ)</strong>。光速的恒定性，是爱因斯坦狭义相对论的基石，它为宇宙中信息的传播设定了终极速度限制，从而守护了<span class="concept">因果律</span>的尊严，确保了宇宙时间的单向性。而普朗克常数，则是量子力学的核心，它揭示了能量和物质在微观层面的<span class="concept">量子化</span>特性，终结了经典物理学在解释黑体辐射等现象时的“紫外灾难”。</p>
                    <p>这两大常数看似分属不同的物理领域——光速主宰宏观高速世界，普朗克常数揭示微观量子奥秘。然而，它们并非孤立存在，而是在宇宙的深层结构中有着千丝万缕的联系。例如，在普朗克的黑体辐射方程中，光速 c 和普朗克常数 h 同时出现，共同描绘了热辐射的能量分布，这绝非偶然。它们共同构筑了我们宇宙的物理逻辑，从光速的恒定性对时空的约束，到普朗克常数对能量的离散化，两者共同维护着宇宙的秩序与和谐。</p>
                    <p>本篇解读，将跟随搜狐创始人、董事局主席兼CEO，麻省理工学院物理学博士<strong class="highlight">张朝阳</strong>先生的物理课程精髓，从物理逻辑视角深入剖析光速 c 和普朗克常数 h 的核心意义，探讨它们如何在各自领域内扮演着至关重要的角色，以及它们如何在普朗克黑体辐射方程中交织，共同揭示宇宙的深层奥秘。让我们一起，踏上这场探索宇宙基本法则的奇妙旅程！</p>
                </section>

                <section id="light-speed-causality">
                    <h2>第一章：光速的恒定与因果律的守护</h2>
                    <p>“狭义相对论的限制是针对物体在<span class="concept">局部惯性参考系</span>中的运动速度而言的。也就是说，在一个给定的空间区域内，任何信息或物质的传播速度都不能超过光速c。这是<span class="concept">闵可夫斯基时空结构</span>决定的<span class="concept">因果律</span>的体现。” 这段精辟的论述，如同物理学中的交通法规，为宇宙中信息的传递和事件的关联划定了清晰的界限。它告诉我们，光速c不仅仅是一个速度值，更是宇宙深层结构——因果律——的守护者。</p>
                    <p>爱因斯坦的狭义相对论建立在两个基本假设之上：<strong class="highlight">相对性原理</strong>（物理定律在所有惯性参考系中都相同）和<strong class="highlight">光速不变原理</strong>（光在真空中的速度 c 在所有惯性参考系中都相同，与光源的运动状态无关）。正是第二个假设，彻底颠覆了牛顿的绝对时空观，引出了时间膨胀、长度收缩、质能方程 E=mc² 等一系列“反直觉”但已被实验反复验证的结论。</p>
                    <p>在牛顿的经典世界里，时间和空间是相互独立的绝对存在。然而，爱因斯坦的老师闵可夫斯基更进一步，将时间和三维空间巧妙地融合为一个统一的四维实体——<span class="concept">闵可夫斯基时空</span>。在这个四维时空中，一个“点”不再仅仅是空间中的一个位置，而是一个“<span class="concept">事件</span>”，它包含了时间和空间三个坐标 (t, x, y, z)。两个事件之间的“距离”也不再是简单的空间距离，而是一个被称为“<span class="concept">时空间隔</span>”(ds²)的量，其定义为：</p>
                    <p class="formula">ds² = (c*dt)² - dx² - dy² - dz²</p>
                    <p>这个时空间隔有一个神奇的特性：它在所有惯性参考系下都是<strong class="highlight">不变</strong>的，即具有洛伦兹不变性。根据ds²的符号，两个事件之间的关系可以分为三类：类时间隔 (ds² > 0)、类光间隔 (ds² = 0) 和类空间隔 (ds² < 0)。只有类时和类光间隔的事件才可能存在因果关联。</p>
                    <p><span class="concept">因果律</span>，即原因必定发生在结果之前，是物理学乃至我们日常经验中最基本的法则之一。如果这个法则被打破，世界将陷入逻辑混乱。狭义相对论通过光速不变原理和闵可夫斯基时空结构，巧妙地维护了因果律的尊严。核心在于，任何携带<strong class="highlight">能量或信息</strong>的物理过程，其传播速度都不能超过真空光速c。如果存在超光速信号，由于“同时的相对性”，在一个参考系中，信号发送事件A发生在接收事件B之前，但在另一个高速运动的参考系中，事件B完全有可能发生在事件A之前，导致因果关系被颠倒，产生逻辑悖论。</p>
                    <p>光速c就像一个宇宙警察，它限制了所有“交通工具”（信息和物质）的最高速度，确保了在所有惯性参考系中，时间的“单向箭头”和事件的因果顺序得以保持一致。任何试图超光速传递信息的行为，都会撞上这堵由时空结构本身建立起来的“因果墙”。因此，光速c不仅仅是一个速度的上限，更是宇宙<strong class="highlight">因果结构稳定性的保证</strong>。</p>
                    <div id="lightConeCausalityAnimation" class="animation-container"></div>
                    <div class="controls">
                        <button id="lccToggleSignal">发送信号 (亚光速/假想超光速)</button>
                        <label for="lccObserverSpeed">观察者速度:</label>
                        <input type="range" id="lccObserverSpeed" min="0" max="0.9" value="0" step="0.05">
                    </div>
                    <p>动画演示：在一个简化的(1+1)维时空图上，中心是一个事件点。演示其未来光锥和过去光锥。用户可以尝试发送一个信号，观察其在光锥内的传播。通过调整“观察者速度”滑块，模拟不同惯性参考系下的时空轴倾斜，并展示如果存在超光速信号，在某些参考系下可能导致因果倒置的现象。</p>
                </section>

                <section id="planck-constant-quantization">
                    <h2>第二章：普朗克常数与能量的量子化</h2>
                    <p>如果说光速 c 揭示了宇宙速度的极限，那么<strong class="highlight">普朗克常数 h (或 ħ)</strong> 则打开了通往微观世界“不连续”本质的大门。它的诞生，源于经典物理学在解释<span class="concept">黑体辐射</span>问题时遭遇的“<strong class="highlight">紫外灾难</strong>”。</p>
                    <p>黑体是一个理想化的物体，它能吸收所有入射的电磁辐射，并以最大效率向外辐射能量。经典物理学（瑞利-金斯公式）预测，黑体辐射的能量会随着频率的升高而无限增大，尤其是在紫外线区域，能量将趋于无穷大，这显然与实验观测不符。实验曲线显示，黑体辐射的能量谱在某个频率达到峰值后，会随着频率的升高而迅速衰减。</p>
                    <p>为了解决这一困境，德国物理学家马克斯·普朗克在 1900 年提出了一个革命性的假设：能量不是连续的，而是以一份份离散的“能量子”（或称“量子”）形式被吸收和辐射。每个能量子的大小与辐射的频率成正比：</p>
                    <p class="formula">E = hν = ħω</p>
                    <p>其中 ν 是频率，ω 是圆频率，而 h 就是<span class="concept">普朗克常数</span>（h ≈ 6.626 × 10⁻³⁴ J·s），ħ 是约化普朗克常数（ħ = h / 2π）。这个假设意味着，能量的传递就像爬楼梯，你不能停留在楼梯中间，只能站在某一级台阶上。只有当能量达到某个最小的“量子”值时，才能被吸收或释放。正是这个大胆的假设，使得普朗克成功推导出了与实验数据完美吻合的<span class="concept">黑体辐射公式</span>，从而避免了“紫外灾难”。</p>
                    <p>普朗克常数 h 的引入，标志着物理学从经典连续性观念向量子离散性观念的转变。它不仅仅是一个数值，更是微观世界中能量、动量、角动量等物理量<strong class="highlight">量子化</strong>的根本标志。它告诉我们，在微观层面，世界并非无限光滑，而是由一个个不可再分的“量子”构成的。</p>
                    <div id="quantizationAnimation" class="animation-container"></div>
                    <div class="controls">
                        <button id="qaToggleEnergy">切换能量模式 (连续/量子化)</button>
                        <label for="qaQuantumSize">量子大小:</label>
                        <input type="range" id="qaQuantumSize" min="0.1" max="1" value="0.5" step="0.05">
                    </div>
                    <p>动画演示：一个能量柱状图或阶梯图。在“连续模式”下，能量可以平滑地变化。在“量子化模式”下，能量只能停留在离散的台阶上，无法在台阶之间。量子大小滑块可以概念性地调整能量台阶的高度，直观展示能量量子化的概念。</p>
                </section>

                <section id="planck-formula-interplay">
                    <h2>第三章：普朗克黑体辐射方程中的光速与普朗克常数</h2>
                    <p>普朗克黑体辐射公式，是物理学史上一个里程碑式的成就，它不仅解决了“紫外灾难”，更首次将量子概念引入物理学。这个公式的完整形式是：</p>
                    <p class="formula">I(ω) = (ħω³ / (π²c³)) * (1 / (e^(ħω/(kT)) - 1))</p>
                    <p>或者用频率 ν 表示：</p>
                    <p class="formula">I(ν) = (2hν³ / c²) * (1 / (e^(hν/(kT)) - 1))</p>
                    <p>仔细观察这个公式，我们会发现两个宇宙基本常数——<strong class="highlight">光速 c</strong> 和<strong class="highlight">普朗克常数 h (或 ħ)</strong>——赫然在列，它们在公式中扮演着不可或缺的角色，共同描绘了黑体辐射的能量分布。</p>
                    <p>那么，这两个常数在公式中各自代表了什么，又如何相互作用呢？</p>
                    <ul>
                        <li><strong class="highlight">光速 c 的作用：</strong> 在公式的分母中，光速 c 以 c³ (或 c²) 的形式出现。这反映了电磁波的波动本质以及它们在空间中的传播特性。在经典电磁理论中，电磁波的传播速度就是光速。普朗克公式虽然引入了量子概念，但它仍然描述的是电磁波的辐射，因此光速作为电磁波的基本传播速度，自然会出现在公式中，它与电磁波在单位体积内的模式数量有关。可以说，c 确保了公式与电磁波的波动属性相符。</li>
                        <li><strong class="highlight">普朗克常数 h (或 ħ) 的作用：</strong> 普朗克常数 h (或 ħ) 出现在公式的分子和指数项中。在分子中，它与频率 ω (或 ν) 结合形成 ħω (或 hν)，这正是普朗克能量子假说的核心——能量的最小单位。在指数项 e^(ħω/(kT)) - 1 中，ħω/kT 是一个无量纲的量，它决定了在给定温度 T 下，能量为 ħω 的量子态被激发的概率。当 ħω 远大于 kT 时（即高频区域），指数项会变得非常大，导致整个分母迅速增大，从而使辐射强度 I(ω) 迅速趋近于零。正是这个指数衰减项，有效地“扼杀”了经典理论的“紫外灾难”。可以说，h 确保了公式与能量的量子化属性相符。</li>
                    </ul>
                    <p>因此，普朗克黑体辐射公式是光速 c 和普朗克常数 h 完美结合的典范。光速 c 描述了电磁波在时空中的传播特性，而普朗克常数 h 则描述了能量在微观层面的离散化。两者共同作用，才能够准确地预测黑体辐射的能量分布，既符合电磁波的波动规律，又体现了能量的量子化特性。这个公式的成功，不仅解决了困扰物理学界的难题，更深刻地揭示了宇宙在微观层面的基本法则，为量子力学的诞生奠定了坚实的基础。</p>
                    <div id="planckFormulaAnimation" class="animation-container"></div>
                    <div class="controls">
                        <label for="pfaHbar">普朗克常数 (h):</label>
                        <input type="range" id="pfaHbar" min="0.1" max="2" value="1" step="0.1">
                        <label for="pfaC">光速 (c):</label>
                        <input type="range" id="pfaC" min="0.1" max="2" value="1" step="0.1">
                        <button id="pfaReset">重置参数</button>
                    </div>
                    <p>动画演示：展示普朗克黑体辐射曲线。用户可以调整概念性的“普朗克常数 (h)”和“光速 (c)”滑块，观察它们如何影响曲线的形状。例如，增加 h 会使曲线在高频部分更快衰减，而改变 c 则会影响曲线的整体尺度和峰值位置，直观展示这两个常数在公式中的作用。</p>
                </section>

                <section id="conclusion-constants">
                    <h2>结语：两大常数共同描绘的宇宙图景</h2>
                    <p>光速 c 和普朗克常数 h，是物理学中两大看似独立却又紧密相连的基石。光速 c 作为宇宙中信息和能量传播的终极速度限制，不仅是狭义相对论的核心，更是<span class="concept">因果律</span>的坚定守护者，确保了宇宙事件的逻辑顺序不会被颠倒。它定义了时空的结构，划定了事件之间因果联系的边界。</p>
                    <p>而普朗克常数 h，则揭示了微观世界中能量、动量等物理量的<span class="concept">量子化</span>本质。它终结了经典物理学在黑体辐射问题上的“紫外灾难”，标志着量子力学的诞生。h 告诉我们，能量的吸收和释放是离散的，世界在微观层面并非连续光滑。</p>
                    <p>这两大常数在普朗克黑体辐射公式中的共同出现，并非偶然。光速 c 确保了公式与电磁波的波动传播特性相符，而普朗克常数 h 则保证了能量的量子化特性。它们共同作用，才能够准确地描述黑体辐射的能量分布，完美地解决了经典物理的困境。</p>
                    <p>从宏观宇宙的因果秩序，到微观粒子的量子行为，光速 c 和普朗克常数 h 共同描绘了一幅和谐而深刻的宇宙图景。它们是理解现代物理学两大支柱——相对论和量子力学——的关键。正是对这些基本常数的深入理解，才使得人类能够不断拓展对宇宙奥秘的认知，并在此基础上发展出无数改变世界的科技，从核能到激光，从半导体到量子计算。张朝阳先生的物理课，正是通过这样对基本常数的透彻剖析，引导我们领略物理学之美，感受宇宙法则的精妙。</p>
                </section>
            </article>
        </main>
        <footer>
            <p>&copy; 2025 光速、普朗克常数与宇宙的秩序解读。内容灵感与核心思想源自张朝阳先生的物理课程。</p>
            <p>本页面所有动画均为概念性、简化性演示，旨在辅助理解，不完全代表真实物理过程的精确模拟。</p>
        </footer>
    </div>

    <script>
        // --- 全局背景星空动画 (复用) ---
        let sketchBackground = function(p) {
            let stars = [];
            const numStars = 150; // 减少一点数量，让页面更清爽
            p.setup = function() {
                let canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('backgroundCanvasContainer');
                for (let i = 0; i < numStars; i++) {
                    stars.push({
                        x: p.random(p.width),
                        y: p.random(p.height),
                        size: p.random(0.3, 2.0), // 减小一点尺寸
                        alpha: p.random(40, 120) // 减小一点亮度
                    });
                }
                p.noStroke();
            };
            p.draw = function() {
                p.clear(); 
                for (let star of stars) {
                    p.fill(180, 200, 235, star.alpha * (p.sin(p.frameCount * 0.008 + star.x * 0.08) * 0.25 + 0.75) ); 
                    p.ellipse(star.x, star.y, star.size, star.size);
                    star.y += star.size * 0.015; 
                    if (star.y > p.height) {
                        star.y = 0;
                        star.x = p.random(p.width);
                    }
                }
            };
            p.windowResized = function() {
                p.resizeCanvas(p.windowWidth, p.height); // Changed p.windowHeight to p.height to maintain aspect ratio
                 stars = []; 
                for (let i = 0; i < numStars; i++) {
                    stars.push({
                        x: p.random(p.width),
                        y: p.random(p.height),
                        size: p.random(0.3, 2.0),
                        alpha: p.random(40, 120)
                    });
                }
            };
        };
        new p5(sketchBackground);

        // --- 动画1: 光锥与因果律 ---
        let sketchLightConeCausality = function(p) {
            let signalType = 'subluminal'; // 'subluminal' or 'ftl'
            let observerSpeed = 0; // v/c, from 0 to 0.9
            let signalPos = {x:0, t:0};
            let eventA = {x: -100, t: 0}; // Event A (sender)
            let playing = false;

            p.setup = function() {
                let container = p.select('#lightConeCausalityAnimation');
                let canvas = p.createCanvas(container.width, container.height);
                canvas.parent('lightConeCausalityAnimation');
                p.select('#lccToggleSignal').mousePressed(() => {
                    if (signalType === 'subluminal') {
                        signalType = 'ftl';
                    } else {
                        signalType = 'subluminal';
                    }
                    resetAnimation();
                });
                let speedSlider = p.select('#lccObserverSpeed');
                speedSlider.input(() => {
                    observerSpeed = parseFloat(speedSlider.value());
                    p.redraw(); // Redraw to show axis tilt
                });
                resetAnimation();
                p.noLoop(); p.redraw();
            };

            function resetAnimation() {
                signalPos = {x: eventA.x, t: eventA.t};
                playing = true;
                p.loop();
            }
            
            function drawAxesAndCone(ox, oy, scale, v_over_c) {
                // Draw tilted axes for observer's frame (conceptual)
                p.push();
                p.translate(ox, oy);
                let angle = p.atan(v_over_c); // Angle of tilt for x' axis
                
                // ct' axis (tilted)
                p.stroke(100, 150, 200);
                p.line(0, -oy + 50, 0, oy - 50); // Original ct axis
                p.text("ct", 10, -oy + 50);

                // x' axis (tilted)
                p.rotate(-angle); // Rotate canvas to draw x' axis straight
                p.line(-ox + 50, 0, ox - 50, 0); // Original x axis
                p.text("x", ox - 50, -10);
                p.pop();

                // Draw light cone for Event A (always 45 degrees in any inertial frame)
                p.stroke(255,255,0,100); // Yellow for light cone
                let coneTipX = ox + eventA.x * scale;
                let coneTipY = oy - eventA.t * scale; // t is 0, so coneTipY is oy
                let coneHeight = p.height * 0.4;
                p.line(coneTipX, coneTipY, coneTipX + coneHeight, coneTipY - coneHeight); // c=1, slope=1
                p.line(coneTipX, coneTipY, coneTipX - coneHeight, coneTipY - coneHeight);
                p.line(coneTipX, coneTipY, coneTipX + coneHeight, coneTipY + coneHeight);
                p.line(coneTipX, coneTipY, coneTipX - coneHeight, coneTipY + coneHeight);
            }

            p.draw = function() {
                p.background(1, 4, 9);
                let scale = 1; // Scale for drawing
                let originX = p.width / 2;
                let originY = p.height / 2; // Time=0 at middle of Y axis

                drawAxesAndCone(originX, originY, scale, observerSpeed);

                // Event A
                p.fill(0,255,0); p.ellipse(originX + eventA.x*scale, originY - eventA.t*scale, 10,10);
                p.text("A (发送)", originX + eventA.x*scale - 25, originY - eventA.t*scale -10);

                // Signal propagation
                if(playing){
                    let signalSpeed = (signalType === 'subluminal') ? 0.5 : 1.5; // c=1
                    signalPos.x = eventA.x + signalSpeed * (p.frameCount - p.floor(p.frameCount/100)*100); // Simplified time
                    signalPos.t = (p.frameCount - p.floor(p.frameCount/100)*100);
                }
                
                p.fill(255,0,0); 

            p.draw = function() {
                p.background(1, 4, 9);
                p.translate(molecule.x, molecule.y);

                // Draw atoms
                let atom1X = -30;
                let atom2X = 30;
                let bondLength = 60;

                // Vibration
                vibrationPhase += 0.1;
                let currentVibration = p.sin(vibrationPhase) * molecule.vibrateAmp * 20; // Scale vibration for visual

                p.push();
                p.rotate(molecule.angle); // Rotation
                
                // Draw bond
                p.stroke(150, 150, 255);
                p.strokeWeight(3);
                p.line(atom1X - currentVibration, 0, atom2X + currentVibration, 0);

                // Draw atoms
                p.fill(255, 100, 100);
                p.noStroke();
                p.ellipse(atom1X - currentVibration, 0, 20, 20);
                p.ellipse(atom2X + currentVibration, 0, 20, 20);
                p.pop();

                molecule.angle += molecule.rotateSpeed;

                // Text for state
                p.fill(255); p.textSize(16); p.textAlign(p.CENTER);
                p.text(`当前温度: ${tempState === 'room' ? '室温 (振动冻结)' : '高温 (振动激活)'}`, 0, p.height/2 - 50);
                p.text(`振动幅度: ${molecule.vibrateAmp.toFixed(1)}`, 0, p.height/2 - 30);
                p.text(`旋转速度: ${molecule.rotateSpeed.toFixed(2)}`, 0, p.height/2 - 10);
                p.text(`能量阈值: ${energyThreshold.toFixed(2)}`, 0, p.height/2 + 10);

                if (p.frameCount % 60 === 0) { // Update every second for continuous animation
                    if (tempState === 'room' && molecule.vibrateAmp > 0.01) {
                        p.loop(); // Keep looping for subtle vibration
                    } else if (tempState === 'high' && molecule.vibrateAmp > 0.01) {
                        p.loop(); // Keep looping for active vibration
                    } else {
                        p.noLoop(); // Stop if no significant animation
                    }
                }
            };
            p.windowResized = function() {
                let container = p.select('#specificHeatAnimation');
                p.resizeCanvas(container.width, container.height);
                molecule.x = p.width / 2;
                molecule.y = p.height / 2;
                p.redraw();
            };
        };
        new p5(sketchSpecificHeat);

        // --- 动画2: 黑体辐射与普朗克的“能量子” ---
        let sketchBlackbodyRadiation = function(p) {
            let currentView = 'quantum'; // 'classic' or 'quantum'
            let temperature = 3000; // Kelvin

            p.setup = function() {
                let container = p.select('#blackbodyAnimation');
                let canvas = p.createCanvas(container.width, container.height);
                canvas.parent('blackbodyAnimation');
                p.select('#bbToggleView').mousePressed(() => {
                    currentView = (currentView === 'classic') ? 'quantum' : 'classic';
                    p.redraw();
                });
                let tempSlider = p.select('#bbTemperature');
                tempSlider.input(() => {
                    temperature = parseFloat(tempSlider.value());
                    p.redraw();
                });
                p.noLoop(); p.redraw(); // Draw initial static frame
            };

            p.draw = function() {
                p.background(1, 4, 9);
                p.translate(p.width * 0.1, p.height * 0.9); // Origin at bottom-left for graph

                // Draw axes
                p.stroke(100, 150, 200);
                p.line(0, 0, p.width * 0.8, 0); // Frequency (ω) axis
                p.line(0, 0, 0, -p.height * 0.8); // Intensity (I) axis
                p.fill(200); p.noStroke(); p.textSize(12);
                p.textAlign(p.CENTER); p.text("频率 (ω)", p.width * 0.4, 20);
                p.textAlign(p.RIGHT); p.text("辐射强度 (I)", -10, -p.height * 0.4);

                let maxFreq = p.width * 0.7; // Max frequency on graph
                let maxIntensity = p.height * 0.7; // Max intensity on graph

                p.push();
                p.scale(1, -1); // Flip Y-axis for drawing graph upwards

                // Draw classic (Rayleigh-Jeans) curve
                if (currentView === 'classic') {
                    p.stroke(255, 100, 100); // Red for classic
                    p.noFill();
                    p.beginShape();
                    for (let i = 0; i < maxFreq; i += 1) {
                        let omega = i / (maxFreq / 10); // Scale omega for calculation
                        let intensity = (omega * omega) * temperature * 0.000005; // Simplified RJ formula
                        p.vertex(i, intensity * maxIntensity);
                    }
                    p.endShape();
                    p.fill(255, 100, 100); p.noStroke(); p.textSize(14); p.textAlign(p.LEFT);
                    p.text("经典瑞利-金斯曲线 (紫外灾难)", 10, -maxIntensity + 20);
                }

                // Draw quantum (Planck) curve
                if (currentView === 'quantum') {
                    p.stroke(100, 255, 100); // Green for quantum
                    p.noFill();
                    p.beginShape();
                    let hbar = 1; // Simplified hbar for animation
                    let k = 1; // Simplified k for animation
                    for (let i = 0; i < maxFreq; i += 1) {
                        let omega = i / (maxFreq / 10); // Scale omega for calculation
                        let intensity = (omega * omega * omega) / (p.exp((hbar * omega) / (k * temperature)) - 1) * 0.0000005; // Simplified Planck formula
                        p.vertex(i, intensity * maxIntensity * 100); // Scale for visibility
                    }
                    p.endShape();
                    p.fill(100, 255, 100); p.noStroke(); p.textSize(14); p.textAlign(p.LEFT);
                    p.text("普朗克量子曲线 (与实验吻合)", 10, -maxIntensity + 20);
                }
                p.pop();

                p.fill(255); p.textSize(16); p.textAlign(p.CENTER);
                p.text(`温度: ${temperature} K`, p.width / 2, p.height - 20);
            };
            p.windowResized = function() {
                let container = p.select('#blackbodyAnimation');
                p.resizeCanvas(container.width, container.height);
                p.redraw();
            };
        };
        new p5(sketchBlackbodyRadiation);

        // --- 动画3: 光电效应与爱因斯坦的“光子” ---
        let sketchPhotoelectricEffect = function(p) {
            let lightFrequency = 0.8; // Controls photon energy
            let lightIntensity = 0.5; // Controls number of photons
            let workFunction = 0.5; // W, threshold for electron emission
            let electrons = [];
            let maxElectrons = 50;
            let currentCount = 0;

            p.setup = function() {
                let container = p.select('#photoelectricAnimation');
                let canvas = p.createCanvas(container.width, container.height);
                canvas.parent('photoelectricAnimation');
                
                let freqSlider = p.select('#peFrequency');
                freqSlider.input(() => {
                    lightFrequency = parseFloat(freqSlider.value());
                    resetAnimation();
                });
                let intensitySlider = p.select('#peIntensity');
                intensitySlider.input(() => {
                    lightIntensity = parseFloat(intensitySlider.value());
                    resetAnimation();
                });
                p.select('#peReset').mousePressed(resetAnimation);
                
                resetAnimation();
                p.noLoop(); p.redraw(); // Draw initial static frame
            };

            function resetAnimation() {
                electrons = [];
                currentCount = 0;
                p.loop(); // Start animation
            }

            p.draw = function() {
                p.background(1, 4, 9);

                // Draw light source
                p.fill(255, 255, 0);
                p.ellipse(p.width * 0.1, p.height / 2, 20, 20);
                p.text("光源", p.width * 0.1, p.height / 2 + 25);

                // Draw metal plate (cathode)
                p.fill(100, 100, 150);
                p.rect(p.width * 0.3, p.height * 0.2, 20, p.height * 0.6);
                p.text("阴极 (金属)", p.width * 0.3 + 10, p.height * 0.2 - 10);

                // Draw collecting plate (anode)
                p.fill(100, 100, 150);
                p.rect(p.width * 0.7, p.height * 0.2, 20, p.height * 0.6);
                p.text("阳极 (收集)", p.width * 0.7 + 10, p.height * 0.2 - 10);

                // Emit photons
                if (p.frameCount % (p.floor(20 / lightIntensity)) === 0) { // More photons for higher intensity
                    let photonEnergy = lightFrequency; // Simplified: frequency directly maps to energy
                    if (photonEnergy > workFunction) { // Only emit electron if energy is sufficient
                        electrons.push({
                            x: p.width * 0.3 + 20,
                            y: p.random(p.height * 0.2, p.height * 0.8),
                            vx: (photonEnergy - workFunction) * 5, // Electron speed based on excess energy
                            vy: p.random(-1, 1) * 2 // Small random vertical component
                        });
                    }
                }

                // Update and draw electrons
                for (let i = electrons.length - 1; i >= 0; i--) {
                    let e = electrons[i];
                    e.x += e.vx;
                    e.y += e.vy;

                    p.fill(0, 200, 255); // Blue for electrons
                    p.ellipse(e.x, e.y, 8, 8);

                    if (e.x > p.width * 0.7) { // Electron reached collecting plate
                        electrons.splice(i, 1);
                        currentCount++;
                    }
                    if (e.x > p.width || e.x < 0 || e.y > p.height || e.y < 0) { // Out of bounds
                        electrons.splice(i, 1);
                    }
                }

                // Display info
                p.fill(255); p.textSize(16); p.textAlign(p.LEFT);
                p.text(`光频率 (能量): ${lightFrequency.toFixed(2)}`, 10, 30);
                p.text(`逸出功 (阈值): ${workFunction.toFixed(2)}`, 10, 50);
                p.text(`光电流 (电子数): ${currentCount}`, 10, 70);

                if (electrons.length === 0 && p.frameCount > 100) { // Stop animation if no electrons for a while
                    p.noLoop();
                }
            };
            p.windowResized = function() {
                let container = p.select('#photoelectricAnimation');
                p.resizeCanvas(container.width, container.height);
                resetAnimation();
            };
        };
        new p5(sketchPhotoelectricEffect);

        // --- 动画4: 波粒二象性 (双缝干涉) ---
        let sketchDuality = function(p) {
            let currentMode = 'wave'; // 'wave' or 'particle'
            let particleCount = 1; // Number of particles to simulate
            let particles = [];
            let interferencePattern = []; // For particle mode accumulation
            let patternWidth = 200; // Width of the screen for pattern
            let slitY1, slitY2;
            let slitWidth = 5;
            let screenX;

            p.setup = function() {
                let container = p.select('#dualityAnimation');
                let canvas = p.createCanvas(container.width, container.height);
                canvas.parent('dualityAnimation');
                
                slitY1 = p.height / 2 - 30;
                slitY2 = p.height / 2 + 30;
                screenX = p.width * 0.8;

                p.select('#dualityToggle').mousePressed(() => {
                    currentMode = (currentMode === 'wave') ? 'particle' : 'wave';
                    resetAnimation();
                });
                let particleCountSlider = p.select('#dualityParticleCount');
                particleCountSlider.input(() => {
                    particleCount = parseInt(particleCountSlider.value());
                    resetAnimation();
                });
                
                for (let i = 0; i < patternWidth; i++) {
                    interferencePattern[i] = 0;
                }
                resetAnimation();
                p.noLoop(); p.redraw(); // Draw initial static frame
            };

            function resetAnimation() {
                particles = [];
                for (let i = 0; i < patternWidth; i++) {
                    interferencePattern[i] = 0;
                }
                p.loop(); // Start animation
            }

            p.draw = function() {
                p.background(1, 4, 9);

                // Draw source
                p.fill(255, 255, 0);
                p.ellipse(p.width * 0.1, p.height / 2, 15, 15);
                p.text("光源", p.width * 0.1, p.height / 2 + 20);

                // Draw slits
                p.fill(50, 50, 50);
                p.rect(p.width * 0.4, 0, slitWidth, slitY1 - 10);
                p.rect(p.width * 0.4, slitY1 + 10, slitWidth, slitY2 - (slitY1 + 10));
                p.rect(p.width * 0.4, slitY2 + 10, slitWidth, p.height - (slitY2 + 10));
                p.text("双缝", p.width * 0.4 + 20, p.height / 2);

                // Draw screen
                p.stroke(150);
                p.line(screenX, 0, screenX, p.height);
                p.text("屏幕", screenX + 20, p.height / 2);

                if (currentMode === 'wave') {
                    // Simulate wave propagation
                    p.noFill();
                    p.stroke(100, 200, 255, 150);
                    for (let i = 0; i < 10; i++) {
                        p.ellipse(p.width * 0.1, p.height / 2, p.frameCount * 2 + i * 20, p.frameCount * 2 + i * 20);
                    }
                    
                    // Draw interference pattern on screen (conceptual)
                    p.stroke(255, 255, 0);
                    p.strokeWeight(2);
                    for (let y = 0; y < p.height; y += 5) {
                        let intensity = p.sin(y * 0.1 + p.frameCount * 0.01) * p.sin(y * 0.1 + p.frameCount * 0.01); // Simple sine wave pattern
                        p.line(screenX, y, screenX + intensity * 30, y);
                    }
                    p.fill(255); p.textSize(16); p.textAlign(p.CENTER);
                    p.text("波模式 (干涉图样)", p.width / 2, 30);
                } else { // Particle mode
                    if (p.frameCount % 5 === 0 && particles.length < particleCount) {
                        particles.push({
                            x: p.width * 0.1,
                            y: p.height / 2,
                            vx: p.random(3, 5),
                            vy: p.random(-1, 1) * 0.5,
                            passedSlit: false
                        });
                    }

                    for (let i = particles.length - 1; i >= 0; i--) {
                        let particle = particles[i];
                        p.fill(255, 150, 0);
                        p.ellipse(particle.x, particle.y, 5, 5);

                        particle.x += particle.vx;
                        particle.y += particle.vy;

                        // Check for slit passage
                        if (!particle.passedSlit && particle.x > p.width * 0.4) {
                            if ((particle.y > slitY1 - 10 && particle.y < slitY1 + 10) ||
                                (particle.y > slitY2 - 10 && particle.y < slitY2 + 10)) {
                                particle.passedSlit = true;
                                // Apply a slight random deflection after passing slit
                                particle.vy += p.random(-0.5, 0.5);
                            } else {
                                // If hit barrier, remove or bounce
                                particles.splice(i, 1);
                                continue;
                            }
                        }

                        // If hit screen
                        if (particle.x > screenX) {
                            let patternY = p.map(particle.y, 0, p.height, 0, patternWidth - 1);
                            interferencePattern[p.floor(p.constrain(patternY, 0, patternWidth - 1))] += 1;
                            particles.splice(i, 1);
                        }
                    }

                    // Draw accumulated pattern
                    p.stroke(255, 255, 0);
                    p.strokeWeight(1);
                    let maxVal = p.max(interferencePattern);
                    for (let i = 0; i < patternWidth; i++) {
                        let barHeight = p.map(interferencePattern[i], 0, maxVal, 0, p.height * 0.8);
                        p.line(screenX + 5, p.map(i, 0, patternWidth - 1, 0, p.height), screenX + 5 + barHeight, p.map(i, 0, patternWidth - 1, 0, p.height));
                    }
                    p.fill(255); p.textSize(16); p.textAlign(p.CENTER);
                    p.text(`粒子模式 (数量: ${particleCount})`, p.width / 2, 30);
                }
                if (particles.length === 0 && p.frameCount > 100) {
                    p.noLoop();
                }
            };
            p.windowResized = function() {
                let container = p.select('#dualityAnimation');
                p.resizeCanvas(container.width, container.height);
                slitY1 = p.height / 2 - 30;
                slitY2 = p.height / 2 + 30;
                screenX = p.width * 0.8;
                resetAnimation();
            };
        };
        new p5(sketchDuality);

        // --- 动画5: 康普顿散射 (概念性) ---
        let sketchComptonScattering = function(p) {
            let photon = {x: 50, y: 150, vx: 5, vy: 0, energy: 100, wavelength: 10};
            let electron = {x: 250, y: 150, vx: 0, vy: 0, energy: 0, mass: 10}; // Simplified mass
            let scatteredPhoton = null;
            let scatteredElectron = null;
            let collisionOccurred = false;
            let playing = false;

            p.setup = function() {
                let container = p.select('#comptonScatteringAnimation');
                let canvas = p.createCanvas(container.width, container.height);
                canvas.parent('comptonScatteringAnimation');
                p.select('#csPlay').mousePressed(() => {
                    resetAnimation();
                    playing = true;
                    p.loop();
                });
                resetAnimation();
                p.noLoop(); p.redraw(); // Draw initial static frame
            };

            function resetAnimation() {
                photon = {x: 50, y: 150, vx: 5, vy: 0, energy: 100, wavelength: 10};
                electron = {x: 250, y: 150, vx: 0, vy: 0, energy: 0, mass: 10};
                scatteredPhoton = null;
                scatteredElectron = null;
                collisionOccurred = false;
                playing = false;
            }

            p.draw = function() {
                p.background(1, 4, 9);

                // Draw photon
                p.fill(255, 255, 0);
                p.ellipse(photon.x, photon.y, 10, 10);
                p.text("入射光子", photon.x + 15, photon.y);

                // Draw electron
                p.fill(0, 200, 255);
                p.ellipse(electron.x, electron.y, 15, 15);
                p.text("电子", electron.x + 10, electron.y + 20);

                if (playing) {
                    // Move photon
                    if (!collisionOccurred) {
                        photon.x += photon.vx;
                        photon.y += photon.vy;
                    }

                    // Check for collision
                    let d = p.dist(photon.x, photon.y, electron.x, electron.y);
                    if (d < 15 && !collisionOccurred) {
                        collisionOccurred = true;
                        // Simulate scattering (simplified energy/momentum transfer)
                        let scatterAngle = p.random(p.PI / 4, p.PI * 3 / 4); // Random scatter angle for photon
                        let electronAngle = scatterAngle + p.PI / 2; // Electron recoils roughly perpendicular

                        let photonEnergyLoss = photon.energy * p.random(0.3, 0.7); // Photon loses some energy
                        let electronEnergyGain = photonEnergyLoss;

                        scatteredPhoton = {
                            x: photon.x,
                            y: photon.y,
                            vx: p.cos(scatterAngle) * (photon.energy - photonEnergyLoss) / 10,
                            vy: p.sin(scatterAngle) * (photon.energy - photonEnergyLoss) / 10,
                            energy: photon.energy - photonEnergyLoss,
                            wavelength: photon.wavelength * (photon.energy / (photon.energy - photonEnergyLoss)) // Wavelength increases
                        };

                        scatteredElectron = {
                            x: electron.x,
                            y: electron.y,
                            vx: p.cos(electronAngle) * electronEnergyGain / electron.mass,
                            vy: p.sin(electronAngle) * electronEnergyGain / electron.mass,
                            energy: electronEnergyGain
                        };
                    }

                    // Draw scattered particles
                    if (scatteredPhoton) {
                        scatteredPhoton.x += scatteredPhoton.vx;
                        scatteredPhoton.y += scatteredPhoton.vy;
                        p.fill(255, 255, 0);
                        p.ellipse(scatteredPhoton.x, scatteredPhoton.y, 10, 10);
                        p.text("散射光子", scatteredPhoton.x + 15, scatteredPhoton.y);
                    }
                    if (scatteredElectron) {
                        scatteredElectron.x += scatteredElectron.vx;
                        scatteredElectron.y += scatteredElectron.vy;
                        p.fill(0, 200, 255);
                        p.ellipse(scatteredElectron.x, scatteredElectron.y, 15, 15);
                        p.text("反冲电子", scatteredElectron.x + 10, scatteredElectron.y + 20);
                    }

                    // Display info
                    p.fill(255); p.textSize(14); p.textAlign(p.LEFT);
                    p.text(`入射光子能量: ${photon.energy.toFixed(0)}`, 10, 30);
                    p.text(`入射光子波长: ${photon.wavelength.toFixed(1)}`, 10, 50);
                    if (scatteredPhoton) {
                        p.text(`散射光子能量: ${scatteredPhoton.energy.toFixed(0)}`, 10, 70);
                        p.text(`散射光子波长: ${scatteredPhoton.wavelength.toFixed(1)} (变长)`, 10, 90);
                        p.text(`反冲电子能量: ${scatteredElectron.energy.toFixed(0)}`, 10, 110);
                    }

                    // Stop animation if particles out of bounds
                    if (photon.x > p.width + 50 || (scatteredPhoton && scatteredPhoton.x > p.width + 50)) {
                        playing = false;
                        p.noLoop();
                    }
                } else {
                    p.fill(255,255,255,150); p.textAlign(p.CENTER, p.CENTER); p.textSize(16);
                    p.text("点击播放按钮演示康普顿散射", p.width/2, p.height - 20);
                }
            };
            p.windowResized = function() {
                let container = p.select('#comptonScatteringAnimation');
                p.resizeCanvas(container.width, container.height);
                resetAnimation();
            };
        };
        new p5(sketchComptonScattering);

    </script>
</body>
</html>
