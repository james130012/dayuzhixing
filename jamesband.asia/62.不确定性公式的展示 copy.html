<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æµ·æ£®å ¡ä¸ç¡®å®šæ€§åŸç†äº¤äº’æ¼”ç¤º</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .container {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        .controls {
            background: rgba(255,255,255,0.2);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .control-group {
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        label {
            min-width: 120px;
            font-weight: bold;
        }
        input[type="range"] {
            flex: 1;
            margin: 0 10px;
        }
        .value-display {
            min-width: 80px;
            text-align: right;
            font-family: monospace;
            font-size: 1.1em;
        }
        .canvas-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        canvas {
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            background: rgba(0,0,0,0.3);
        }
        .uncertainty-display {
            background: rgba(255,255,255,0.2);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }
        .uncertainty-value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }
        .explanation {
            background: rgba(255,255,255,0.15);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            line-height: 1.6;
        }
        .preset-buttons {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: rgba(255,255,255,0.2);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸŒŠ æµ·æ£®å ¡ä¸ç¡®å®šæ€§åŸç†äº¤äº’æ¼”ç¤º</h1>
        
        <div class="controls">
            <h3>æ³¢å‡½æ•°å‚æ•°æ§åˆ¶</h3>
            
            <div class="control-group">
                <label>æ³¢åŒ…å®½åº¦ (Ïƒ):</label>
                <input type="range" id="sigma" min="0.5" max="3" step="0.1" value="1">
                <span class="value-display" id="sigmaValue">1.0</span>
            </div>
            
            <div class="control-group">
                <label>ä¸­å¿ƒåŠ¨é‡ (kâ‚€):</label>
                <input type="range" id="k0" min="0" max="5" step="0.1" value="2">
                <span class="value-display" id="k0Value">2.0</span>
            </div>
            
            <div class="control-group">
                <label>ç²’å­è´¨é‡ (m):</label>
                <input type="range" id="mass" min="0.1" max="10" step="0.1" value="1">
                <span class="value-display" id="massValue">1.0</span>
            </div>
            
            <div class="control-group">
                <label>æ³¢å‡½æ•°ç±»å‹:</label>
                <select id="waveType" style="padding: 5px; border-radius: 5px;">
                    <option value="gaussian">é«˜æ–¯æ³¢åŒ… (æœ€å°ä¸ç¡®å®šæ€)</option>
                    <option value="rect">çŸ©å½¢æ³¢åŒ…</option>
                    <option value="triangle">ä¸‰è§’æ³¢åŒ…</option>
                    <option value="exponential">æŒ‡æ•°è¡°å‡</option>
                </select>
            </div>
            
            <div class="preset-buttons">
                <button onclick="setPreset('narrow')">çª„æ³¢åŒ…</button>
                <button onclick="setPreset('wide')">å®½æ³¢åŒ…</button>
                <button onclick="setPreset('optimal')">æœ€ä¼˜æ€</button>
                <button id="animateButton" onclick="toggleAnimation()">å¼€å§‹åŠ¨ç”»</button>
                <button onclick="resetSimulation()">é‡ç½®</button>
            </div>
        </div>

        <div class="canvas-container">
            <div>
                <h3>ä½ç½®ç©ºé—´ Ïˆ(x)</h3>
                <canvas id="positionCanvas" width="400" height="300"></canvas>
            </div>
            <div>
                <h3>åŠ¨é‡ç©ºé—´ Ï†(p)</h3>
                <canvas id="momentumCanvas" width="400" height="300"></canvas>
            </div>
        </div>

        <div class="uncertainty-display">
            <div>ä½ç½®ä¸ç¡®å®šåº¦: <span id="deltaX" class="uncertainty-value">--</span></div>
            <div>åŠ¨é‡ä¸ç¡®å®šåº¦: <span id="deltaP" class="uncertainty-value">--</span></div>
            <div>ä¸ç¡®å®šæ€§ä¹˜ç§¯: <span id="product" class="uncertainty-value">--</span></div>
            <div>ä¸ç†è®ºä¸‹ç•Œæ¯”è¾ƒ: <span id="ratio" class="uncertainty-value">--</span></div>
            <div id="inequalityStatus" style="font-size: 1.5em; margin-top: 10px;"></div>
        </div>

        <div class="explanation">
            <h3>ğŸ” ä¸ºä»€ä¹ˆæ˜¯ä¸ç­‰å·ï¼Ÿ</h3>
            <div id="explanationText">
                <p><strong>Î”x Â· Î”p â‰¥ â„/2</strong> æ˜¯ä¸ç­‰å·çš„åŸå› ï¼š</p>
                <ul>
                    <li><strong>ç­‰å·æ¡ä»¶</strong>ï¼šåªæœ‰é«˜æ–¯æ³¢åŒ…èƒ½è¾¾åˆ°ç­‰å·ï¼ˆæœ€å°ä¸ç¡®å®šæ€ï¼‰</li>
                    <li><strong>ç‰©ç†é™åˆ¶</strong>ï¼šâ„/2 æ˜¯é‡å­åŠ›å­¦çš„ç†è®ºä¸‹ç•Œï¼Œæ— æ³•çªç ´</li>
                    <li><strong>æ•°å­¦åŸºç¡€</strong>ï¼šæ¥è‡ªæŸ¯è¥¿-æ–½ç“¦èŒ¨ä¸ç­‰å¼ï¼Œå¤§å¤šæ•°å‡½æ•°éƒ½æ˜¯ä¸¥æ ¼å¤§äº</li>
                    <li><strong>å®éªŒæ„ä¹‰</strong>ï¼šå°è¯•ä¸åŒæ³¢å‡½æ•°å½¢çŠ¶ï¼Œè§‚å¯Ÿä¸ç¡®å®šæ€§ä¹˜ç§¯çš„å˜åŒ–ï¼</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // è·å–ç”»å¸ƒå’Œæ§åˆ¶å…ƒç´ 
        const posCanvas = document.getElementById('positionCanvas');
        const momCanvas = document.getElementById('momentumCanvas');
        const posCtx = posCanvas.getContext('2d');
        const momCtx = momCanvas.getContext('2d');
        
        let animationId;
        let time = 0;
        let isPlaying = false; // æ–°å¢æ ‡å¿—

        // æ•°å­¦å¸¸æ•°
        const hbar = 1; // è®¾ä¸º1ç®€åŒ–è®¡ç®—
        const theoretical_limit = hbar / 2;

        // æ›´æ–°æ§åˆ¶å€¼æ˜¾ç¤º
        function updateControls() {
            document.getElementById('sigmaValue').textContent = 
                parseFloat(document.getElementById('sigma').value).toFixed(1);
            document.getElementById('k0Value').textContent = 
                parseFloat(document.getElementById('k0').value).toFixed(1);
            document.getElementById('massValue').textContent = 
                parseFloat(document.getElementById('mass').value).toFixed(1);
        }

        // è®¡ç®—æ¦‚ç‡å¯†åº¦
        function calculateProbability(waveFunction) {
            return waveFunction.real * waveFunction.real + 
                   waveFunction.imag * waveFunction.imag;
        }

        // å¤æ•°ç±»
        class Complex {
            constructor(real, imag) {
                this.real = real;
                this.imag = imag;
            }
            
            multiply(other) {
                return new Complex(
                    this.real * other.real - this.imag * other.imag,
                    this.real * other.imag + this.imag * other.real
                );
            }
            
            magnitude() {
                return Math.sqrt(this.real * this.real + this.imag * this.imag);
            }
        }

        // ç”Ÿæˆå¤æ•°æ³¢å‡½æ•°
        function generateComplexWaveFunction(x, sigma_current, k0, type, x0_offset = 0, initialSigma = sigma_current, t = 0, mass = 1) { // æ·»åŠ  initialSigma, t, mass
            const x_relative = x - x0_offset; // ä½¿ç”¨ç›¸å¯¹åæ ‡
            let amplitude = 0;
            let current_sigma = sigma_current;

            if (type === 'gaussian' && t > 0) {
                // é«˜æ–¯æ³¢åŒ…æ‰©æ•£å…¬å¼
                // sigma(t) = sigma_0 * sqrt(1 + (hbar * t / (2 * m * sigma_0^2))^2)
                const term = (hbar * t) / (2 * mass * initialSigma * initialSigma);
                current_sigma = initialSigma * Math.sqrt(1 + term * term);
            }
            
            switch(type) {
                case 'gaussian':
                    amplitude = Math.exp(-x_relative*x_relative/(2*current_sigma*current_sigma));
                    break;
                case 'rect':
                    amplitude = Math.abs(x_relative) <= sigma_current ? 1 : 0; // çŸ©å½¢æ³¢åŒ…ä¸æ‰©æ•£
                    break;
                case 'triangle':
                    amplitude = Math.abs(x_relative) <= sigma_current ? (1 - Math.abs(x_relative)/sigma_current) : 0; // ä¸‰è§’æ³¢åŒ…ä¸æ‰©æ•£
                    break;
                case 'exponential':
                    amplitude = Math.exp(-Math.abs(x_relative)/sigma_current); // æŒ‡æ•°è¡°å‡ä¸æ‰©æ•£
                    break;
            }
            
            return new Complex(
                amplitude * Math.cos(k0 * x_relative), // ç›¸ä½ä¹Ÿä¸ç›¸å¯¹åæ ‡ç›¸å…³
                amplitude * Math.sin(k0 * x_relative)
            );
        }

        // ç®€å•çš„ç¦»æ•£å‚…ç«‹å¶å˜æ¢
        function discreteFT(positionData, dx) {
            const N = positionData.length;
            const momentumData = [];
            const dk = 2 * Math.PI / (N * dx);
            
            for (let n = 0; n < N; n++) {
                let real = 0, imag = 0;
                const k = (n - N/2) * dk;
                
                for (let m = 0; m < N; m++) {
                    const x = (m - N/2) * dx;
                    const phase = -k * x;
                    real += positionData[m].real * Math.cos(phase) - 
                           positionData[m].imag * Math.sin(phase);
                    imag += positionData[m].real * Math.sin(phase) + 
                           positionData[m].imag * Math.cos(phase);
                }
                
                momentumData.push(new Complex(real * dx, imag * dx));
            }
            
            return momentumData;
        }

        // è®¡ç®—ä¸ç¡®å®šåº¦
        function calculateUncertainties(posData, momData, dx, dk) {
            const N = posData.length;
            
            // è®¡ç®—å½’ä¸€åŒ–å› å­
            let norm = 0;
            for (let i = 0; i < N; i++) {
                norm += posData[i].magnitude() * posData[i].magnitude() * dx;
            }
            
            // è®¡ç®—ä½ç½®æœŸæœ›å€¼å’Œä¸ç¡®å®šåº¦
            let x_mean = 0, x2_mean = 0;
            for (let i = 0; i < N; i++) {
                const x = (i - N/2) * dx;
                const prob = posData[i].magnitude() * posData[i].magnitude() / norm;
                x_mean += x * prob * dx;
                x2_mean += x * x * prob * dx;
            }
            const deltaX = Math.sqrt(x2_mean - x_mean * x_mean);
            
            // è®¡ç®—åŠ¨é‡æœŸæœ›å€¼å’Œä¸ç¡®å®šåº¦
            let p_mean = 0, p2_mean = 0;
            let mom_norm = 0;
            for (let i = 0; i < N; i++) {
                mom_norm += momData[i].magnitude() * momData[i].magnitude() * dk;
            }
            
            for (let i = 0; i < N; i++) {
                const p = (i - N/2) * dk * hbar;
                const prob = momData[i].magnitude() * momData[i].magnitude() / mom_norm;
                p_mean += p * prob * dk;
                p2_mean += p * p * prob * dk;
            }
            const deltaP = Math.sqrt(p2_mean - p_mean * p_mean);
            
            return { deltaX, deltaP };
        }

        // ç»˜åˆ¶å‡½æ•°
        function drawGraph(ctx, data, color, label, minPhysicalX, maxPhysicalX, dxOrDk, N, isMomentum = false) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            // ç»˜åˆ¶åæ ‡è½´
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, ctx.canvas.height/2); // Xè½´
            ctx.lineTo(ctx.canvas.width, ctx.canvas.height/2);
            ctx.moveTo(ctx.canvas.width/2, 0); // Yè½´
            ctx.lineTo(ctx.canvas.width/2, ctx.canvas.height);
            ctx.stroke();

            // ç»˜åˆ¶åˆ»åº¦
            ctx.fillStyle = 'white';
            ctx.font = '10px Arial';
            const tickLength = 5;

            // Xè½´åˆ»åº¦
            const numTicksX = 5; // åˆ»åº¦æ•°é‡
            for (let i = 0; i <= numTicksX; i++) {
                const physicalValue = minPhysicalX + (maxPhysicalX - minPhysicalX) * (i / numTicksX);
                const x_canvas = mapPhysicalToCanvasX(physicalValue, minPhysicalX, maxPhysicalX, ctx.canvas.width);
                ctx.beginPath();
                ctx.moveTo(x_canvas, ctx.canvas.height/2 - tickLength);
                ctx.lineTo(x_canvas, ctx.canvas.height/2 + tickLength);
                ctx.stroke();
                ctx.fillText(physicalValue.toFixed(1), x_canvas - 10, ctx.canvas.height/2 + 20);
            }

            // Yè½´åˆ»åº¦ (åªç»˜åˆ¶ä¸­å¿ƒçº¿ï¼Œå› ä¸ºæ¦‚ç‡å¯†åº¦æ˜¯æ­£çš„)
            ctx.fillText('0', ctx.canvas.width/2 + 10, ctx.canvas.height/2 + 10);
            
            // ç»˜åˆ¶æ¦‚ç‡å¯†åº¦
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const maxProb = Math.max(...data.map(d => d.magnitude() * d.magnitude()));
            const scaleY = ctx.canvas.height * 0.4 / maxProb; // Yè½´ç¼©æ”¾
            
            for (let i = 0; i < data.length; i++) {
                let physicalX;
                if (isMomentum) {
                    physicalX = (i - N/2) * dxOrDk * hbar; // åŠ¨é‡ç©ºé—´æ˜¯ p = k * hbar
                } else {
                    physicalX = (i - N/2) * dxOrDk; // ä½ç½®ç©ºé—´æ˜¯ x
                }
                
                const x_canvas = mapPhysicalToCanvasX(physicalX, minPhysicalX, maxPhysicalX, ctx.canvas.width);
                
                const prob = data[i].magnitude() * data[i].magnitude();
                const y_canvas = ctx.canvas.height/2 - prob * scaleY;
                
                if (i === 0) ctx.moveTo(x_canvas, y_canvas);
                else ctx.lineTo(x_canvas, y_canvas);
            }
            ctx.stroke();
            
            // ç»˜åˆ¶æ ‡ç­¾
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.fillText(label, 10, 25);
        }

        // è¾…åŠ©å‡½æ•°ï¼šå°†ç‰©ç†åæ ‡æ˜ å°„åˆ°ç”»å¸ƒåæ ‡
        function mapPhysicalToCanvasX(physicalX, minPhysical, maxPhysical, canvasWidth) {
            const rangePhysical = maxPhysical - minPhysical;
            return (physicalX - minPhysical) * (canvasWidth / rangePhysical);
        }

        // ä¸»æ›´æ–°å‡½æ•°
        function update() {
            const sigma = parseFloat(document.getElementById('sigma').value);
            const k0 = parseFloat(document.getElementById('k0').value);
            const waveType = document.getElementById('waveType').value;
            const mass = parseFloat(document.getElementById('mass').value); // è·å–è´¨é‡
            
            const v_group = k0 * hbar / mass; // è®¡ç®—ç¾¤é€Ÿåº¦
            const x0_offset = v_group * time; // è®¡ç®—æ³¢åŒ…ä¸­å¿ƒåç§»
            
            // ç”Ÿæˆä½ç½®ç©ºé—´æ•°æ®
            const N = 256;
            const dx = 0.1;
            const positionData = [];
            
            // åˆå§‹sigmaç”¨äºæ‰©æ•£è®¡ç®—ï¼Œåªåœ¨é«˜æ–¯æ³¢åŒ…æ—¶æœ‰æ•ˆ
            const initialSigma = parseFloat(document.getElementById('sigma').value); 

            for (let i = 0; i < N; i++) {
                const x = (i - N/2) * dx; // ç‰©ç† x åæ ‡
                positionData.push(generateComplexWaveFunction(x, sigma, k0, waveType, x0_offset, initialSigma, time, mass));
            }
            
            // è®¡ç®—åŠ¨é‡ç©ºé—´æ•°æ®ï¼ˆå‚…ç«‹å¶å˜æ¢ï¼‰
            const momentumData = discreteFT(positionData, dx);
            const dk = 2 * Math.PI / (N * dx);
            
            // è®¡ç®—ä¸ç¡®å®šåº¦
            const { deltaX, deltaP } = calculateUncertainties(positionData, momentumData, dx, dk);
            const product = deltaX * deltaP;
            const ratio = product / theoretical_limit;
            
            // æ›´æ–°æ˜¾ç¤º
            document.getElementById('deltaX').textContent = deltaX.toFixed(3);
            document.getElementById('deltaP').textContent = deltaP.toFixed(3);
            document.getElementById('product').textContent = product.toFixed(3);
            document.getElementById('ratio').textContent = ratio.toFixed(2) + 'å€';
            
            const statusElement = document.getElementById('inequalityStatus');
            if (ratio >= 1) {
                statusElement.textContent = 'âœ… æ»¡è¶³ä¸ç¡®å®šæ€§åŸç†';
                statusElement.style.color = '#4CAF50';
            } else {
                statusElement.textContent = 'âŒ è¿åä¸ç¡®å®šæ€§åŸç†ï¼ˆè®¡ç®—è¯¯å·®ï¼‰';
                statusElement.style.color = '#f44336';
            }
            
            // å®šä¹‰ç‰©ç† x å’Œ p çš„ç»˜å›¾èŒƒå›´
            const X_MIN_PHYSICAL = -20;
            const X_MAX_PHYSICAL = 20;
            const P_MIN_PHYSICAL = (-N/2) * dk * hbar;
            const P_MAX_PHYSICAL = (N/2) * dk * hbar;

            // ç»˜åˆ¶å›¾å½¢
            drawGraph(posCtx, positionData, '#FF6B6B', 'Ïˆ(x)', X_MIN_PHYSICAL, X_MAX_PHYSICAL, dx, N, false);
            drawGraph(momCtx, momentumData, '#4ECDC4', 'Ï†(p)', P_MIN_PHYSICAL, P_MAX_PHYSICAL, dk, N, true);
        }

        // é¢„è®¾å‡½æ•°
        function setPreset(type) {
            switch(type) {
                case 'narrow':
                    document.getElementById('sigma').value = 0.5;
                    document.getElementById('k0').value = 3;
                    break;
                case 'wide':
                    document.getElementById('sigma').value = 2.5;
                    document.getElementById('k0').value = 1;
                    break;
                case 'optimal':
                    document.getElementById('sigma').value = 1;
                    document.getElementById('k0').value = 2;
                    document.getElementById('waveType').value = 'gaussian';
                    break;
            }
            updateControls();
            update();
        }

        // åŠ¨ç”»å‡½æ•°
        function animate() {
            if (isPlaying) {
                time += 0.05;
                update();
                animationId = requestAnimationFrame(animate);
            }
        }

        // æ’­æ”¾/æš‚åœæŒ‰é’®é€»è¾‘
        function toggleAnimation() {
            isPlaying = !isPlaying;
            const animateButton = document.getElementById('animateButton');
            if (isPlaying) {
                animateButton.textContent = 'æš‚åœåŠ¨ç”»';
                animate(); // å¼€å§‹åŠ¨ç”»å¾ªç¯
            } else {
                animateButton.textContent = 'å¼€å§‹åŠ¨ç”»';
                cancelAnimationFrame(animationId); // åœæ­¢åŠ¨ç”»å¾ªç¯
            }
        }

        // é‡ç½®æŒ‰é’®é€»è¾‘
        function resetSimulation() {
            cancelAnimationFrame(animationId);
            isPlaying = false;
            time = 0;
            document.getElementById('sigma').value = 1;
            document.getElementById('k0').value = 2;
            document.getElementById('mass').value = 1;
            document.getElementById('waveType').value = 'gaussian';
            updateControls();
            update();
            document.getElementById('animateButton').textContent = 'å¼€å§‹åŠ¨ç”»';
        }

        // äº‹ä»¶ç›‘å¬å™¨
        document.getElementById('sigma').addEventListener('input', () => {
            updateControls();
            update();
        });
        
        document.getElementById('k0').addEventListener('input', () => {
            updateControls();
            update();
        });
        
        document.getElementById('mass').addEventListener('input', () => {
            updateControls();
            update();
        });
        
        document.getElementById('waveType').addEventListener('change', update);

        // åˆå§‹åŒ–
        updateControls();
        update();
    </script>
</body>
</html>
