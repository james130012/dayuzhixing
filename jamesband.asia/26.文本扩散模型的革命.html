<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>深入解读 LLaDA：大型语言扩散模型</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            font-size: 16pt; /* 三号字体 */
            line-height: 1.8;
            background-color: #f0f2f5; /* 轻松的背景色 */
            color: #333;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            overflow-x: hidden; /* 防止横向滚动 */
        }

        .a3-container {
            width: 100%;
            max-width: 794px; /* A3 width at 72 DPI for reference, but we'll use this for content width on screen */
            background-color: #ffffff;
            padding: 30px; /* 普通页边距的模拟 */
            margin: 20px;
            box-shadow: 0 0 15px rgba(0,0,0,0.1);
            border-radius: 8px;
        }

        header {
            text-align: center;
            border-bottom: 2px solid #0366d6; /* GitHub-like blue accent */
            padding-bottom: 20px;
            margin-bottom: 30px;
        }

        header h1 {
            font-size: 2.5em; /* 相对三号字体的放大 */
            color: #0366d6;
            margin: 0;
            font-weight: 600;
        }

        header p {
            font-size: 0.9em;
            color: #586069; /* GitHub-like secondary text color */
            margin-top: 10px;
        }

        section {
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px dashed #e1e4e8; /* GitHub-like subtle border */
        }

        section:last-child {
            border-bottom: none;
        }

        h2 {
            font-size: 1.8em;
            color: #1a1a1a;
            border-bottom: 1px solid #eaecef;
            padding-bottom: 10px;
            margin-top: 0;
            margin-bottom: 20px;
            font-weight: 500;
        }
        
        h3 {
            font-size: 1.3em;
            color: #0366d6;
            margin-top: 25px;
            margin-bottom: 15px;
            font-weight: 500;
        }

        p, li {
            text-align: justify;
            color: #24292e; /* GitHub-like text color */
        }

        strong, .highlight {
            color: #d73a49; /* GitHub-like red for emphasis */
            font-weight: 600;
        }

        .formula {
            font-family: 'Courier New', Courier, monospace;
            background-color: #f6f8fa; /* GitHub-like code block background */
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid #e1e4e8;
            display: inline-block;
            margin: 5px 0;
            color: #111;
        }

        .animation-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 25px 0;
            padding: 15px;
            border: 1px solid #d1d5da;
            border-radius: 6px;
            background-color: #f9f9f9;
        }

        .p5CanvasContainer { /* General container for P5 canvas */
            margin-bottom: 10px;
            border: 1px solid #ccc;
            width: 100%; /* Make it responsive */
            max-width: 600px; /* Limit max width for larger screens */
            height: 300px; /* Default height, can be overridden by specific canvas CSS */
            display: flex; /* For centering canvas if p5 creates it smaller */
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Ensure canvas content doesn't spill */
        }
        
        #actionCoverageCanvasContainer { 
             height: 350px; 
        }
        #reversalCurseCanvasContainer {
            height: 250px;
        }
        #dialogueAnimationCanvasContainer {
            height: 300px;
        }


        button.play-button {
            background-color: #2ea44f; /* GitHub green */
            color: white;
            border: 1px solid rgba(27,31,35,.15);
            padding: 8px 16px;
            font-size: 0.85em; /* Relative to body */
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            margin: 5px;
        }

        button.play-button:hover {
            background-color: #22863a;
        }

        @media (max-width: 768px) {
            body {
                font-size: 14pt; 
            }
            .a3-container {
                margin: 10px;
                padding: 20px;
            }
            header h1 {
                font-size: 2em;
            }
            h2 {
                font-size: 1.5em;
            }
            .p5CanvasContainer {
                height: 250px; 
            }
            #actionCoverageCanvasContainer {
                 height: 300px; 
            }
            #reversalCurseCanvasContainer {
                height: 200px;
            }
            #dialogueAnimationCanvasContainer {
                height: 250px;
            }
        }

        @media (max-width: 480px) {
            body {
                font-size: 12pt; 
            }
             .a3-container {
                margin: 5px;
                padding: 15px;
            }
            header h1 {
                font-size: 1.8em;
            }
            h2 {
                font-size: 1.3em;
            }
            button.play-button {
                padding: 6px 12px;
                font-size: 0.8em;
            }
            .p5CanvasContainer {
                height: 200px; 
            }
             #actionCoverageCanvasContainer {
                 height: 250px; 
            }
            #reversalCurseCanvasContainer {
                height: 180px;
            }
            #dialogueAnimationCanvasContainer {
                height: 220px;
            }
        }

        .emoji-bullet li::before {
            content: "✨"; 
            margin-right: 8px;
        }
        ul {
            list-style-type: none;
            padding-left: 0;
        }
        ul li {
            padding-left: 1.5em; 
            position: relative;
            margin-bottom: 0.5em;
        }
         ul.emoji-bullet li::before {
            position: absolute;
            left: 0;
            top: 0.1em; 
        }

    </style>
</head>
<body>
    <div class="a3-container">
        <header>
            <h1>🚀 LLaDA深度漫游：大型语言扩散模型全解析 🤯</h1>
            <p>抛开传统，拥抱扩散！一篇物理逻辑视角的趣味解读，带你探索语言模型新大陆！</p>
        </header>

        <section id="intro">
            <h2>👋 嘿，语言模型界的新星 LLaDA 来了！</h2>
            <p>在人工智能的璀璨星空中，大型语言模型 (LLMs) 无疑是最耀眼的那颗星。长期以来，<strong>自回归模型 (Autoregressive Models, ARMs)</strong> 像是武林中的泰山北斗，稳坐头把交椅。它们如同一个耐心的故事家，一个词一个词地为我们编织出流畅的文本。但现在，一位名为 <strong>LLaDA (Large Language Diffusion Model)</strong> 的挑战者横空出世，它大胆地喊出：“嘿，ARMs，语言生成的武林盟主宝座，扩散模型也想试试！”</p>
            <p>LLaDA 这位小伙子，可不是说说而已。它是一个从零开始，在预训练和监督微调 (SFT) 的标准套路下成长起来的<strong>扩散模型</strong>。简单来说，它不像自回归模型那样一个字一个字地“挤牙膏”，而是采用了一种更“大刀阔斧”的方式来生成文本。这篇解读，就让我们用轻松活泼的视角，深入 LLaDA 的“物理逻辑”，看看它是如何工作的，又有哪些独门绝技！</p>
        </section>

        <section id="how-it-works">
            <h2>🧐 LLaDA 的“独门秘籍”：扩散模型是个啥？</h2>
            <p>要理解 LLaDA，我们得先搞明白“扩散模型”和传统的“自回归模型”有啥不一样。想象一下，你要写一句话：</p>
            <ul class="emoji-bullet">
                <li><strong>自回归模型 (ARM) 的套路</strong>：它会先想第一个词，比如“今天”，然后基于“今天”想第二个词“天气”，再基于“今天天气”想第三个词“真好”，一步一步，像接龙一样。著名的 GPT 系列就是这个路子。它的公式可以简单理解为：P(句子) = P(词1) * P(词2|词1) * P(词3|词1,词2) * ...</li>
                <li><strong>扩散模型 (LLaDA) 的新玩法</strong>：LLaDA 不这么玩。它更像一个“修复大师”。它先拿到一个“被搞乱”或者“部分隐藏”的句子（比如，一些词被替换成了特殊标记 `[MASK]`，这就是所谓的<strong>前向数据掩码过程</strong>），然后它的任务就是把这些 `[MASK]` 替换回正确的词，让句子恢复原貌（这就是<strong>反向过程</strong>，用一个Transformer模型来预测被掩码的词元）。这个过程可能要迭代好几次，每次都让句子更清晰、更准确一点。它通过优化一个似然边界，提供了一种有原则的概率推断生成方法。</li>
            </ul>
            <p>这种“先打乱再恢复”或者“从模糊到清晰”的策略，是不是有点像我们玩拼图，或者像侦探根据蛛丝马迹还原案件真相？LLaDA 就是这样一位语言世界的“修复侦探”！</p>
            
            <h3>🎬 动画演示1：ARM vs. Diffusion 概念大比拼</h3>
            <div class="animation-container">
                <p>传统“接龙” vs LLaDA“填词大师”</p>
                <div id="armVsDiffusionCanvasContainer" class="p5CanvasContainer"></div>
                <button id="playArmVsDiffusion" class="play-button">播放概念动画</button>
            </div>
        </section>
        
        <section id="llada-process">
            <h2>⚙️ LLaDA 的“工作流水线”：掩码与预测的艺术</h2>
            <p>LLaDA 的核心工作流程可以分为两大步：</p>
            <ol>
                <li><strong>前向过程 (Forward Process - 数据加噪/掩码)</strong>: 想象我们有一句完整的话，比如“阳光正好微风不燥”。在前向过程中，LLaDA 会随机“遮盖”掉一些词，变成类似“阳光 `[MASK]` 微风 `[MASK]`”的样子。这个“遮盖”的程度是可以控制的，从轻微遮盖到几乎全被遮盖。这个过程为模型提供了学习数据分布的“原材料”。</li>
                <li><strong>反向过程 (Reverse Process - 学习预测/去噪)</strong>: 接下来，LLaDA 的“大脑”——一个标准的 Transformer 模型——就要上场了。它的任务是看着这些被遮盖的句子，努力猜出 `[MASK]` 后面应该是啥词。通过大量的学习，模型逐渐掌握了从“残缺”文本中恢复出完整、流畅、有意义的文本的能力。它不是一次性完成，而是像雕琢玉石一样，逐步求精。</li>
            </ol>
            <p>这种通过“预测被掩码词元”来学习的方式，让 LLaDA 能够深刻理解文本的内在结构和语义关联。</p>

            <h3>🎬 动画演示2：LLaDA 的前向掩码与反向预测过程</h3>
            <div class="animation-container">
                <p>看LLaDA如何“先破坏，后建设”！</p>
                <div id="maskingPredictionCanvasContainer" class="p5CanvasContainer"></div>
                <button id="playMaskingPrediction" class="play-button">播放掩码与预测动画</button>
            </div>
        </section>

        <section id="performance">
            <h2>🏆 LLaDA 的“成绩单”：实力不容小觑！</h2>
            <p>光说不练假把式，LLaDA 的表现究竟如何呢？研究论文可是给出了响当当的数据：</p>
            <ul class="emoji-bullet">
                <li><strong class="highlight">强大的可扩展性</strong>：LLaDA 在各项基准测试中都展现了优秀的扩展能力。这意味着模型参数越多，能力就越强，而且比研究者自己构建的自回归模型基线表现更好。这就像练武奇才，学的越多，功夫越高深！</li>
                <li><strong class="highlight">比肩顶尖高手</strong>：令人瞩目的是，LLaDA 8B (80亿参数版本) 在<strong>上下文学习 (in-context learning)</strong> 方面，已经能和像 LLaMA3 8B 这样的顶尖自回归模型打个平手。这意味着你给 LLaDA 一些例子，它就能迅速学会并举一反三。</li>
                <li><strong class="highlight">指令“听得懂，做得好”</strong>：经过监督微调 (SFT) 之后，LLaDA 在遵循指令方面表现也相当出色，尤其是在多轮对话等场景中，展现了令人印象深刻的能力。你让它干啥，它能理解并努力去完成。</li>
            </ul>

            <h3>🎬 动画演示3：LLaDA 的可扩展性优势 (示意动画)</h3>
            <div class="animation-container">
                <p>LLaDA 与 ARM 基线模型的性能增长对比（概念展示）</p>
                <div id="scalabilityCanvasContainer" class="p5CanvasContainer" style="height: 300px;"></div>
                <button id="playScalability" class="play-button">播放扩展性动画</button>
            </div>
        </section>

        <section id="special-features">
            <h2>✨ LLaDA 的“独门绝技”：不止于生成</h2>
            <p>除了常规操作表现优异，LLaDA 还有一些特别的“才艺表演”，其中最引人注目的就是成功解决了所谓的<strong>“逆转诅咒” (Reversal Curse)</strong>。</p>
            <p>什么是“逆转诅咒”呢？有些语言模型，你问它“A 的爸爸是 B”，它能答出来。但你反过来问“B 的儿子是 A 吗？”或者基于“A的上句是B”，问“B的下句是A吗”，它可能就懵了。LLaDA 在这方面有奇效！论文中提到，在一个“诗歌反向补全”任务中，LLaDA 甚至<strong>超越了强大的 GPT-40</strong> (根据论文Table 14，GPT-40是作者用于对比的一个模型名称，可能指代某版本的GPT-4或类似模型)。</p>
            <p>例如，当被问到“但闻人语响”的上一句是什么时（这是一个知识型的问题，需要理解诗句的顺序），LLaDA 能够正确回答“空山不见人”，而 GPT-40 则给出了错误的答案。这表明 LLaDA 对知识的理解和应用可能具有某些不同于传统 ARM 的优势。</p>

            <h3>🎬 动画演示4：“逆转诅咒”破解实录</h3>
            <div class="animation-container">
                <p>LLaDA 如何机智应对“逆转”提问！</p>
                <div id="reversalCurseCanvasContainer" class="p5CanvasContainer"></div>
                <button id="playReversalCurse" class="play-button">展示逆转诅咒案例</button>
            </div>

            <h3>💬 多轮对话小能手 (示意)</h3>
            <p>LLaDA 在经过监督微调后，能够进行流畅的多轮对话，准确理解上下文并给出相关回应。想象一下这样的对话场景：</p>
            <div class="animation-container">
                <p>LLaDA 的流畅对话体验（概念展示）</p>
                <div id="dialogueAnimationCanvasContainer" class="p5CanvasContainer"></div>
                <button id="playDialogue" class="play-button">开始对话演示</button>
            </div>
        </section>

        <section id="conclusion">
            <h2>💡 总结：扩散模型，LLM 的下一片蓝海？</h2>
            <p>LLaDA 的出现，无疑给大型语言模型领域注入了一股新鲜血液。它用实力证明了，<strong>扩散模型不仅可行，而且极具潜力</strong>，足以挑战自回归模型在 LLM 领域的统治地位。那些我们曾经认为与自回归模型固有绑定的关键能力，如上下文学习、指令遵循等，LLaDA 表示：“我也可以！”</p>
            <p>当然，LLaDA 的探索之路才刚刚开始。但它的成功，无疑为未来的语言模型研究打开了一扇新的大门。或许，在不久的将来，基于扩散思想的语言模型会和自回归模型并驾齐驱，甚至在某些特定领域展现出更独特的优势。让我们拭目以待，看看 LLaDA 和它的扩散模型同伴们，将如何继续书写语言智能的新篇章！</p>
            <p class="highlight">总而言之，LLaDA 不仅仅是一个新模型，更是一种新思路，一种对现有范式发起的有力挑战。这对于整个 AI 领域来说，都是令人兴奋的进展！🎉</p>
            <p><strong>核心公式思想 (文本模式)</strong>:</p>
            <p>扩散模型的核心可以通俗理解为两个过程：</p>
            <ul class="emoji-bullet">
                <li><strong>前向加噪/掩码 (q)</strong>: q(x_t | x_{t-1}) 表示从上一步的状态 x_{t-1} 如何通过加一点点“噪声”或“掩码”得到当前状态 x_t。不断重复这个过程，原始数据 x_0 最终会变成接近纯噪声或完全掩码的状态 x_T。</li>
                <li><strong>反向去噪/预测 (p_theta)</strong>: p_theta(x_{t-1} | x_t) 表示模型如何学习从当前噪声/掩码状态 x_t 预测出上一步更清晰的状态 x_{t-1}。模型参数是 theta。通过优化这个预测过程，模型学会了生成。</li>
            </ul>
            <p>LLaDA 的具体实现是用 Transformer 来参数化这个反向预测过程，目标是预测被掩盖的词元。</p>
        </section>
        
        <footer>
            <p style="text-align:center; font-size: 0.8em; color: #6a737d;">
                本文基于对 arXiv:2502.09992v2 [cs.CL] "Large Language Diffusion Models" 论文摘要和核心概念的解读与演绎。
                <br/>动画效果为概念展示，旨在帮助理解。页面风格参考 GitHub。
            </p>
        </footer>

    </div>

    <script>
    // P5.js Animation Scripts

    // --- Animation 1: ARM vs. Diffusion ---
    let armVsDiffusionSketch = function(p) {
        let armTokens = ["Token 1", "Token 2", "Token 3", "Token 4"];
        // let diffusionTokens = ["[M]", "[M]", "[M]", "[M]"]; // Not directly used in this simplified animation logic
        let armProgress = -1;
        let diffusionProgress = 0;
        let diffusionStates = [
            ["[M]", "[M]", "[M]", "[M]"],
            ["Word A", "[M]", "[M]", "Word D"],
            ["Word A", "Word B", "[M]", "Word D"],
            ["Word A", "Word B", "Word C", "Word D"]
        ];
        let active = false;
        let canvasWidth, canvasHeight;

        p.setup = function() {
            let container = document.getElementById('armVsDiffusionCanvasContainer');
            canvasWidth = container.offsetWidth;
            canvasHeight = container.offsetHeight;
            let canvas = p.createCanvas(canvasWidth, canvasHeight);
            canvas.parent('armVsDiffusionCanvasContainer');
            p.textAlign(p.CENTER, p.CENTER);
            p.textSize(canvasHeight / 15);
            drawStatic(); // Initial draw
            // p.noLoop(); // Start paused, loop controlled by 'active' flag
        };
        
        p.windowResized = function() {
            let container = document.getElementById('armVsDiffusionCanvasContainer');
            if (container) { // Check if container exists
                canvasWidth = container.offsetWidth;
                canvasHeight = container.offsetHeight;
                p.resizeCanvas(canvasWidth, canvasHeight);
                p.textSize(canvasHeight / 15);
                if (!active) drawStatic(); // Redraw static if not active
            }
        };

        function drawStatic() {
            p.background(240);
            p.fill(0);
            p.text("自回归模型 (ARM)", canvasWidth * 0.25, canvasHeight * 0.1);
            p.text("扩散模型 (LLaDA)", canvasWidth * 0.75, canvasHeight * 0.1);

            // ARM boxes (Static display based on initial armProgress)
            for (let i = 0; i < armTokens.length; i++) {
                p.stroke(0);
                p.fill(255);
                p.rect(canvasWidth * 0.1 + i * (canvasWidth * 0.35 / armTokens.length), canvasHeight * 0.2, canvasWidth * 0.3 / armTokens.length, canvasHeight * 0.2);
                p.fill(0);
                if (i <= armProgress && armProgress !== -1) { // Show token if it's part of initial static state (though armProgress starts at -1)
                    p.text(armTokens[i], canvasWidth * 0.1 + i * (canvasWidth * 0.35 / armTokens.length) + (canvasWidth * 0.15 / armTokens.length), canvasHeight * 0.3);
                } else if (armProgress === -1 && i === 0 && !active) { // Special case for very first static draw before animation
                     // Do nothing or show placeholder if needed
                }
            }

            // Diffusion boxes (Static display based on initial diffusionProgress)
            let currentDiffusionDisplayStatic = diffusionStates[diffusionProgress];
            for (let i = 0; i < currentDiffusionDisplayStatic.length; i++) {
                p.stroke(0);
                p.fill(255);
                p.rect(canvasWidth * 0.6 + i * (canvasWidth * 0.35 / currentDiffusionDisplayStatic.length), canvasHeight * 0.2, canvasWidth * 0.3 / currentDiffusionDisplayStatic.length, canvasHeight * 0.2);
                p.fill(0);
                p.text(currentDiffusionDisplayStatic[i], canvasWidth * 0.6 + i * (canvasWidth * 0.35 / currentDiffusionDisplayStatic.length) + (canvasWidth * 0.15 / currentDiffusionDisplayStatic.length), canvasHeight * 0.3);
            }
            p.text("迭代次数: " + (diffusionProgress + 1), canvasWidth * 0.75, canvasHeight * 0.5);


            if (!active) {
                 p.fill(100, 100, 100, 150);
                 p.rect(0, 0, canvasWidth, canvasHeight);
                 p.fill(255);
                 p.textSize(canvasHeight / 10);
                 p.text("点击按钮播放", canvasWidth/2, canvasHeight/2);
                 p.textSize(canvasHeight / 15); // Reset text size
            }
        }
        
        p.draw = function() {
            if (!active) {
                // drawStatic(); // Continuously draw static if not active, or rely on button press to redraw
                return;
            }
            
            p.background(240);
            p.fill(0);
            p.text("自回归模型 (ARM)", canvasWidth * 0.25, canvasHeight * 0.1);
            p.text("扩散模型 (LLaDA)", canvasWidth * 0.75, canvasHeight * 0.1);

            // ARM animation
            if (p.frameCount % 30 === 0 && armProgress < armTokens.length -1) {
                armProgress++;
            }
            for (let i = 0; i < armTokens.length; i++) {
                p.stroke(0);
                p.fill(255); // Default box fill
                p.rect(canvasWidth * 0.1 + i * (canvasWidth * 0.35 / armTokens.length), canvasHeight * 0.2, canvasWidth * 0.3 / armTokens.length, canvasHeight * 0.2);
                if (i <= armProgress) {
                    p.fill(50, 200, 50); // Highlight filled token background
                    p.rect(canvasWidth * 0.1 + i * (canvasWidth * 0.35 / armTokens.length), canvasHeight * 0.2, canvasWidth * 0.3 / armTokens.length, canvasHeight * 0.2); // Redraw rect with color
                    p.fill(0); // Text color
                    p.text(armTokens[i], canvasWidth * 0.1 + i * (canvasWidth * 0.35 / armTokens.length) + (canvasWidth * 0.15 / armTokens.length), canvasHeight * 0.3);
                }
            }
             // Arrow for ARM
            if (armProgress < armTokens.length -1 && armProgress >=0) {
                p.stroke(0); p.fill(0); // Ensure arrow is drawn
                p.line(canvasWidth * 0.1 + armProgress * (canvasWidth * 0.35 / armTokens.length) + (canvasWidth * 0.3 / armTokens.length), canvasHeight * 0.3,
                       canvasWidth * 0.1 + (armProgress+1) * (canvasWidth * 0.35 / armTokens.length), canvasHeight * 0.3);
            }


            // Diffusion animation
            if (p.frameCount % 45 === 0 && diffusionProgress < diffusionStates.length - 1) {
                diffusionProgress++;
            }
             let currentDiffusionDisplayAnim = diffusionStates[diffusionProgress];
            for (let i = 0; i < currentDiffusionDisplayAnim.length; i++) {
                p.stroke(0);
                p.fill(255); // Default box fill
                p.rect(canvasWidth * 0.6 + i * (canvasWidth * 0.35 / currentDiffusionDisplayAnim.length), canvasHeight * 0.2, canvasWidth * 0.3 / currentDiffusionDisplayAnim.length, canvasHeight * 0.2);
                if(currentDiffusionDisplayAnim[i] !== "[M]") {
                    p.fill(50, 50, 200); // Highlight revealed token background
                     p.rect(canvasWidth * 0.6 + i * (canvasWidth * 0.35 / currentDiffusionDisplayAnim.length), canvasHeight * 0.2, canvasWidth * 0.3 / currentDiffusionDisplayAnim.length, canvasHeight * 0.2); // Redraw rect with color
                }
                p.fill(0); // Text color
                p.text(currentDiffusionDisplayAnim[i], canvasWidth * 0.6 + i * (canvasWidth * 0.35 / currentDiffusionDisplayAnim.length) + (canvasWidth * 0.15 / currentDiffusionDisplayAnim.length), canvasHeight * 0.3);
            }
            p.fill(0); // Iteration text color
            p.text("迭代次数: " + (diffusionProgress + 1), canvasWidth * 0.75, canvasHeight * 0.5);


            if (armProgress >= armTokens.length -1 && diffusionProgress >= diffusionStates.length -1) {
                active = false; // Stop animation
                drawStatic(); // Draw final static frame
            }
        };

        p.startAnimation = function() {
            armProgress = -1;
            diffusionProgress = 0;
            active = true;
            p.loop(); // Ensure p5 loop is running
        };
    };
    let p5_armVsDiffusion;


    // --- Animation 2: Masking and Prediction ---
    let maskingPredictionSketch = function(p) {
        let originalText = ["大", "型", "语", "言", "模", "型"];
        let maskedText = [];
        let predictedText = [];
        let stage = 0; // 0: initial, 1: masking, 2: masked, 3: predicting, 4: predicted
        let maskIndices = [];
        let predictionProgress = 0;
        let active = false;
        let canvasWidth, canvasHeight;

        p.setup = function() {
            let container = document.getElementById('maskingPredictionCanvasContainer');
            canvasWidth = container.offsetWidth;
            canvasHeight = container.offsetHeight;
            let canvas = p.createCanvas(canvasWidth, canvasHeight);
            canvas.parent('maskingPredictionCanvasContainer');
            p.textAlign(p.CENTER, p.CENTER);
            p.textSize(canvasHeight / 8); // Initial text size
            resetAnimation();
            drawStatic();
            // p.noLoop(); // Controlled by 'active'
        };

        p.windowResized = function() {
            let container = document.getElementById('maskingPredictionCanvasContainer');
             if (container) {
                canvasWidth = container.offsetWidth;
                canvasHeight = container.offsetHeight;
                p.resizeCanvas(canvasWidth, canvasHeight);
                p.textSize(canvasHeight / 8); // Reset text size
                if (!active) drawStatic();
            }
        };
        
        function resetAnimation() {
            maskedText = [...originalText]; // Should be empty or original based on stage
            predictedText = [];
            maskIndices = [];
            predictionProgress = 0;
            stage = 0;
            maskedText = Array(originalText.length).fill(" "); // Start with blank for initial display if needed
            // Or, for initial display of original text before masking:
            // maskedText = [...originalText];
        }

        function drawStatic() {
            p.background(240);
            p.fill(0);
            let currentTextToShow;
            let title = " ";

            if (stage === 0) { 
                currentTextToShow = originalText; // Show original text before animation starts
                title = "原始文本 (准备掩码)";
            } else if (stage === 1 || stage === 2) { 
                currentTextToShow = maskedText;
                title = stage === 1 ? "前向掩码中..." : "掩码完成";
            } else if (stage === 3 || stage === 4) { 
                currentTextToShow = predictedText;
                 title = stage === 3 ? "反向预测中..." : "预测完成!";
            } else { // Default case if stage is undefined
                currentTextToShow = originalText;
                title = "原始文本";
            }
            
            p.textSize(canvasHeight / 12);
            p.text(title, canvasWidth/2, canvasHeight * 0.2);
            p.textSize(canvasHeight / 8); // Main text size

            let spacing = canvasWidth / (currentTextToShow.length + 1);
            for (let i = 0; i < currentTextToShow.length; i++) {
                let charToShow = currentTextToShow[i] || " "; // Handle undefined if array is sparse
                if (stage === 1 && maskIndices.includes(i) && p.frameCount % 10 < 5 && active) { 
                     p.fill(200,0,0);
                } else if (stage === 3 && maskedText[i] === "[M]" && i > predictionProgress && active) {
                     p.fill(150); 
                } else if (stage === 3 && maskedText[i] === "[M]" && i === predictionProgress && p.frameCount % 10 < 5 && active) {
                     p.fill(0,150,0); 
                }
                else {
                     p.fill(0);
                }
                p.text(charToShow, spacing * (i + 1), canvasHeight * 0.6);
            }
             if (!active && stage === 0) { // Only show "Click to play" when truly inactive and at stage 0
                 p.fill(100, 100, 100, 150);
                 p.rect(0, 0, canvasWidth, canvasHeight);
                 p.fill(255);
                 p.textSize(canvasHeight / 10);
                 p.text("点击按钮播放", canvasWidth/2, canvasHeight/2);
                 p.textSize(canvasHeight / 8); // Reset text size
            }
        }

        p.draw = function() {
            if (!active) {
                drawStatic(); // Keep drawing static frame if not active
                return;
            }
            p.background(240);
             p.textSize(canvasHeight / 12); // Title text size
             let title = "";

            if (stage === 0) { // Should not happen if active is true, but as a fallback
                title = "准备中...";
                maskedText = [...originalText]; // Ensure maskedText is initialized
                predictedText = Array(originalText.length).fill("[M]"); // Initialize predictedText with masks
            } else if (stage === 1) { // Masking
                title = "前向掩码中...";
                if (p.frameCount % 20 === 0) {
                    if (maskIndices.length < 3) { 
                        let newIndex;
                        do {
                            newIndex = p.floor(p.random(originalText.length));
                        } while (maskIndices.includes(newIndex));
                        maskIndices.push(newIndex);
                        maskedText[newIndex] = "[M]";
                    } else {
                        stage = 2; 
                        predictedText = [...maskedText]; // Copy masked state to predictedText for next stage
                    }
                }
            } else if (stage === 2) {
                 title = "掩码完成";
                 if(p.frameCount % 60 === 0) stage = 3; // Automatically move to prediction after a pause
            } else if (stage === 3) { // Predicting
                 title = "反向预测中...";
                if (p.frameCount % 30 === 0) {
                    if (predictionProgress < originalText.length) {
                        // Only "predict" if it was a mask
                        if (maskedText[predictionProgress] === "[M]") { 
                            predictedText[predictionProgress] = originalText[predictionProgress];
                        } else {
                           // If it wasn't a mask, it should already be correct in predictedText
                           // Or ensure it's copied if predictedText wasn't initialized properly
                           predictedText[predictionProgress] = originalText[predictionProgress];
                        }
                        predictionProgress++;
                    } else {
                        stage = 4; 
                    }
                }
            } else if (stage === 4) {
                title = "预测完成!";
                active = false;
                drawStatic(); // Draw final static frame
                // p.noLoop(); // Stop p5 loop
            }
            
            p.fill(0);
            p.text(title, canvasWidth/2, canvasHeight * 0.2);
            p.textSize(canvasHeight / 8); // Main text size

            let currentTextDisplay = (stage <=1) ? maskedText : predictedText; // Show maskedText during stage 0 and 1
            if (stage === 0 && !active) currentTextDisplay = originalText; // Show original before starting

            let spacing = canvasWidth / (currentTextDisplay.length + 1);
            for (let i = 0; i < currentTextDisplay.length; i++) {
                 let charToDisplay = currentTextDisplay[i] || " ";
                 if (stage === 1 && maskIndices.includes(i) && p.frameCount % 10 < 5) {
                     p.fill(200,0,0); 
                } else if (stage === 3 && maskedText[i] === "[M]" && i >= predictionProgress ) { // Highlight masks yet to be "predicted"
                     p.fill(150); 
                     if (i === predictionProgress && p.frameCount % 10 < 5) p.fill(0,150,0); // Blinking for current prediction target
                } else {
                     p.fill(0);
                }
                p.text(charToDisplay, spacing * (i + 1), canvasHeight * 0.6);
            }
        };

        p.startAnimation = function() {
            resetAnimation(); // Reset all states
            maskedText = [...originalText]; // Start with original text for masking stage
            predictedText = Array(originalText.length).fill(" "); // Initialize predicted text for later
            stage = 1; // Start masking
            active = true;
            p.loop(); // Ensure p5 loop is running
        };
    };
    let p5_maskingPrediction;


    // --- Animation 3: Scalability (Conceptual) ---
    let scalabilitySketch = function(p) {
        let sizes = ["小模型", "中模型", "LLaDA 8B"];
        let armPerformance = [0, 0, 0]; 
        let lladaPerformance = [0, 0, 0]; 
        let targetArm = [0.3, 0.5, 0.6];
        let targetLlada = [0.35, 0.65, 0.85];
        let active = false;
        let canvasWidth, canvasHeight;
        let barWidth;

        p.setup = function() {
            let container = document.getElementById('scalabilityCanvasContainer');
            canvasWidth = container.offsetWidth;
            canvasHeight = container.offsetHeight;
            let canvas = p.createCanvas(canvasWidth, canvasHeight);
            canvas.parent('scalabilityCanvasContainer');
            p.textAlign(p.CENTER, p.CENTER);
            barWidth = canvasWidth / (sizes.length * 3.5); // Adjusted for better spacing
            drawStatic();
            // p.noLoop();
        };
        
        p.windowResized = function() {
            let container = document.getElementById('scalabilityCanvasContainer');
            if (container) {
                canvasWidth = container.offsetWidth;
                canvasHeight = container.offsetHeight;
                p.resizeCanvas(canvasWidth, canvasHeight);
                barWidth = canvasWidth / (sizes.length * 3.5); // Recalculate bar width
                if (!active) drawStatic();
            }
        };

        function drawStatic(){
            p.background(240);
            p.fill(0);
            p.textSize(canvasHeight * 0.08);
            p.text("模型性能 (示意)", canvasWidth / 2, canvasHeight * 0.1);

            let groupSpacing = canvasWidth / sizes.length;
            let barGroupWidth = barWidth * 2.2; // Width for a pair of bars + small gap

            for (let i = 0; i < sizes.length; i++) {
                let groupCenterX = (i + 0.5) * groupSpacing;
                let x_arm = groupCenterX - barGroupWidth / 2 + barWidth * 0.1; // Adjust for centering
                let x_llada = x_arm + barWidth * 1.1;
                
                p.fill(150, 0, 0, 150); 
                p.rect(x_arm, canvasHeight * 0.8 - armPerformance[i] * canvasHeight * 0.6, barWidth, armPerformance[i] * canvasHeight * 0.6);
                p.fill(0, 0, 150, 150); 
                p.rect(x_llada, canvasHeight * 0.8 - lladaPerformance[i] * canvasHeight * 0.6, barWidth, lladaPerformance[i] * canvasHeight * 0.6);
                
                p.fill(0);
                p.textSize(canvasHeight * 0.06);
                p.text(sizes[i], groupCenterX, canvasHeight * 0.9);
            }
             // Legend
            p.textSize(canvasHeight * 0.05); // Smaller legend text
            p.fill(150, 0, 0); p.rect(canvasWidth * 0.05, canvasHeight * 0.15, canvasWidth*0.03, canvasHeight*0.03); 
            p.text("ARM 基线", canvasWidth * 0.05 + canvasWidth*0.04 + p.textWidth("ARM 基线")/2 , canvasHeight * 0.15 + canvasHeight*0.015);
            p.fill(0, 0, 150); p.rect(canvasWidth * 0.05, canvasHeight * 0.2, canvasWidth*0.03, canvasHeight*0.03); 
            p.text("LLaDA", canvasWidth * 0.05 + canvasWidth*0.04 + p.textWidth("LLaDA")/2, canvasHeight * 0.2 + canvasHeight*0.015);

            if (!active) {
                 p.fill(100, 100, 100, 150);
                 p.rect(0, 0, canvasWidth, canvasHeight);
                 p.fill(255);
                 p.textSize(canvasHeight * 0.1);
                 p.text("点击按钮播放", canvasWidth/2, canvasHeight/2);
            }
        }

        p.draw = function() {
            if (!active) {
                drawStatic();
                return;
            }
            
            p.background(240);
            p.fill(0);
            p.textSize(canvasHeight * 0.08);
            p.text("模型性能 (示意)", canvasWidth / 2, canvasHeight * 0.1);

            let animationSpeed = 0.005; // Slower speed for smoother growth
            let allDone = true;
            
            let groupSpacing = canvasWidth / sizes.length;
            let barGroupWidth = barWidth * 2.2; 

            for (let i = 0; i < sizes.length; i++) {
                if (armPerformance[i] < targetArm[i]) {
                    armPerformance[i] += animationSpeed;
                    allDone = false;
                }
                armPerformance[i] = p.min(armPerformance[i], targetArm[i]);

                if (lladaPerformance[i] < targetLlada[i]) {
                    lladaPerformance[i] += animationSpeed * 1.2; 
                     allDone = false;
                }
                lladaPerformance[i] = p.min(lladaPerformance[i], targetLlada[i]);

                let groupCenterX = (i + 0.5) * groupSpacing;
                let x_arm = groupCenterX - barGroupWidth / 2 + barWidth * 0.1;
                let x_llada = x_arm + barWidth * 1.1;
                
                p.fill(200, 50, 50); 
                p.rect(x_arm, canvasHeight * 0.8 - armPerformance[i] * canvasHeight * 0.6, barWidth, armPerformance[i] * canvasHeight * 0.6);
                p.fill(50, 50, 200); 
                p.rect(x_llada, canvasHeight * 0.8 - lladaPerformance[i] * canvasHeight * 0.6, barWidth, lladaPerformance[i] * canvasHeight * 0.6);
                
                p.fill(0);
                p.textSize(canvasHeight * 0.06);
                p.text(sizes[i], groupCenterX, canvasHeight * 0.9);
            }
            
            // Legend
            p.textSize(canvasHeight * 0.05);
            p.fill(200, 50, 50); p.rect(canvasWidth * 0.05, canvasHeight * 0.15, canvasWidth*0.03, canvasHeight*0.03); 
            p.text("ARM 基线", canvasWidth * 0.05 + canvasWidth*0.04 + p.textWidth("ARM 基线")/2 , canvasHeight * 0.15 + canvasHeight*0.015);
            p.fill(50, 50, 200); p.rect(canvasWidth * 0.05, canvasHeight * 0.2, canvasWidth*0.03, canvasHeight*0.03); 
            p.text("LLaDA", canvasWidth * 0.05 + canvasWidth*0.04 + p.textWidth("LLaDA")/2, canvasHeight * 0.2 + canvasHeight*0.015);


            if (allDone) {
                active = false;
                drawStatic(); // Draw final static frame
            }
        };

        p.startAnimation = function() {
            armPerformance = [0, 0, 0];
            lladaPerformance = [0, 0, 0];
            active = true;
            p.loop();
        };
    };
    let p5_scalability;


    // --- Animation 4: Reversal Curse Example ---
    let reversalCurseSketch = function(p) {
        let question = "“但闻人语响” 的上一句是?";
        let lladaAnswer = "空山不见人 ✔";
        let gpt40Answer = "无可奈何花... ✘"; // Example incorrect answer
        let phase = 0; // 0: question, 1: llada thinking, 2: llada answer, 3: gpt40 thinking, 4: gpt40 answer, 5: done
        let thinkingTimer = 0;
        let active = false;
        let canvasWidth, canvasHeight;

        p.setup = function() {
            let container = document.getElementById('reversalCurseCanvasContainer');
            canvasWidth = container.offsetWidth;
            canvasHeight = container.offsetHeight;
            let canvas = p.createCanvas(canvasWidth, canvasHeight);
            canvas.parent('reversalCurseCanvasContainer');
            p.textAlign(p.CENTER, p.CENTER);
            drawStatic();
            // p.noLoop();
        };

        p.windowResized = function() {
            let container = document.getElementById('reversalCurseCanvasContainer');
            if (container) {
                canvasWidth = container.offsetWidth;
                canvasHeight = container.offsetHeight;
                p.resizeCanvas(canvasWidth, canvasHeight);
                 if (!active) drawStatic();
            }
        };

        function drawStatic(){
             p.background(240);
             p.fill(0);
             p.textSize(canvasHeight * 0.12);
             p.text(question, canvasWidth / 2, canvasHeight * 0.25); // Centered question a bit lower

            if (phase >= 2) { // Show LLaDA's answer if already revealed
                p.textSize(canvasHeight * 0.1);
                p.text("LLaDA:", canvasWidth * 0.25, canvasHeight * 0.55);
                p.fill(0, 150, 0);
                p.text(lladaAnswer, canvasWidth * 0.25, canvasHeight * 0.7);
            }
             if (phase >= 4) { // Show GPT-40's answer if already revealed
                p.fill(0); // Reset color
                p.textSize(canvasHeight * 0.1);
                p.text("GPT-40 (示意):", canvasWidth * 0.75, canvasHeight * 0.55);
                p.fill(200, 0, 0);
                p.text(gpt40Answer, canvasWidth * 0.75, canvasHeight * 0.7);
            }


            if (!active && phase === 0) { // Show overlay only if truly inactive at the start
                 p.fill(100, 100, 100, 150);
                 p.rect(0, 0, canvasWidth, canvasHeight);
                 p.fill(255);
                 p.textSize(canvasHeight * 0.15);
                 p.text("点击按钮播放", canvasWidth/2, canvasHeight/2);
            }
        }

        p.draw = function() {
             if (!active) {
                drawStatic();
                return;
            }
            p.background(240);
            p.fill(0);
            p.textSize(canvasHeight * 0.12);
            p.text(question, canvasWidth / 2, canvasHeight * 0.25);

            p.textSize(canvasHeight * 0.1);
            if (phase >= 1) { 
                p.text("LLaDA:", canvasWidth * 0.25, canvasHeight * 0.55);
                if (phase === 1) { 
                    p.text("思考中" + ".".repeat(p.floor(thinkingTimer / 10) % 4), canvasWidth * 0.25, canvasHeight * 0.7);
                } else if (phase >= 2) {
                    p.fill(0, 150, 0);
                    p.text(lladaAnswer, canvasWidth * 0.25, canvasHeight * 0.7);
                }
            }

            if (phase >= 3) { 
                p.fill(0); // Reset color
                p.text("GPT-40 (示意):", canvasWidth * 0.75, canvasHeight * 0.55);
                 if (phase === 3) { 
                    p.text("思考中" + ".".repeat(p.floor(thinkingTimer / 10) % 4), canvasWidth * 0.75, canvasHeight * 0.7);
                } else if (phase >= 4) {
                    p.fill(200, 0, 0);
                    p.text(gpt40Answer, canvasWidth * 0.75, canvasHeight * 0.7);
                }
            }
            
            if (active) thinkingTimer++;

            if (phase === 0 && active) { phase = 1; thinkingTimer = 0;} // Should be set by startAnimation
            else if (phase === 1 && thinkingTimer > 45) { phase = 2; thinkingTimer = 0;} // Longer thinking
            else if (phase === 2 && thinkingTimer > 45) { phase = 3; thinkingTimer = 0;}
            else if (phase === 3 && thinkingTimer > 45) { phase = 4; thinkingTimer = 0;}
            else if (phase === 4 && thinkingTimer > 60) { 
                phase = 5; 
                active = false; 
                drawStatic(); // Draw final static frame
            }
        };

        p.startAnimation = function() {
            phase = 1; // Start with LLaDA thinking
            thinkingTimer = 0;
            active = true;
            p.loop();
        };
    };
    let p5_reversalCurse;

    // --- Animation 5: Multi-turn Dialogue ---
    let dialogueSketch = function(p) {
        let dialogue = [
            {speaker: "User", text: "介绍一下LLaDA。"},
            {speaker: "LLaDA", text: "LLaDA是扩散语言模型."},
            {speaker: "User", text: "它比ARM强吗?"},
            {speaker: "LLaDA", text: "在某些方面是的！"}
        ];
        let currentTurn = -1; // Start before the first turn
        let typedText = "";
        let charIndex = 0;
        let active = false; // Controls the typing animation for the current turn
        let canvasWidth, canvasHeight;
        let bubblePadding, textPadding, bubbleVMargin;


        function calculateMetrics() {
            bubblePadding = canvasWidth * 0.05;
            textPadding = canvasWidth * 0.02;
            bubbleVMargin = canvasHeight * 0.03;
        }

        p.setup = function() {
            let container = document.getElementById('dialogueAnimationCanvasContainer');
            canvasWidth = container.offsetWidth;
            canvasHeight = container.offsetHeight;
            calculateMetrics();
            let canvas = p.createCanvas(canvasWidth, canvasHeight);
            canvas.parent('dialogueAnimationCanvasContainer');
            p.textAlign(p.LEFT, p.TOP);
            drawStatic(); // Initial static display
            // p.noLoop(); // Loop controlled by active and nextTurn
        };

        p.windowResized = function() {
            let container = document.getElementById('dialogueAnimationCanvasContainer');
            if (container) {
                canvasWidth = container.offsetWidth;
                canvasHeight = container.offsetHeight;
                calculateMetrics();
                p.resizeCanvas(canvasWidth, canvasHeight);
                drawStatic(); // Redraw based on current state
            }
        };

        function drawStatic(){
            p.background(230, 235, 240); 
            p.textSize(canvasHeight * 0.065); // Adjusted text size
            let yPos = bubbleVMargin;

            for(let i=0; i <= currentTurn && i < dialogue.length; i++){
                if (yPos > canvasHeight - bubbleVMargin) break; // Stop if no more space

                let entry = dialogue[i];
                // Use fully typed text for static display of previous turns
                let displayString = (i === currentTurn && active) ? typedText : entry.text; 
                
                let textWidthVal = p.textWidth(entry.speaker + ": " + displayString);
                let bubbleWidth = p.min(canvasWidth * 0.7, textWidthVal + 2 * textPadding);
                let bubbleHeight = canvasHeight * 0.16; // Fixed height for simplicity

                if (entry.speaker === "User") {
                    p.fill(80, 180, 80); 
                    let userBubbleX = canvasWidth - bubbleWidth - bubblePadding;
                    p.rect(userBubbleX, yPos, bubbleWidth, bubbleHeight, 10);
                    p.fill(0);
                    p.text(entry.speaker + ": " + displayString, userBubbleX + textPadding, yPos + textPadding, bubbleWidth - 2*textPadding, bubbleHeight - 2*textPadding);
                } else { // LLaDA
                    p.fill(100, 150, 220); 
                    p.rect(bubblePadding, yPos, bubbleWidth, bubbleHeight, 10);
                    p.fill(255);
                    p.text(entry.speaker + ": " + displayString, bubblePadding + textPadding, yPos + textPadding, bubbleWidth - 2*textPadding, bubbleHeight - 2*textPadding);
                }
                yPos += bubbleHeight + bubbleVMargin;
            }
             if (currentTurn === -1 && !active) { // Initial "Play" message
                 p.fill(100, 100, 100, 150);
                 p.rect(0, 0, canvasWidth, canvasHeight);
                 p.fill(0); // Black text for better contrast on overlay
                 p.textAlign(p.CENTER, p.CENTER);
                 p.textSize(canvasHeight * 0.1);
                 p.text("点击按钮开始对话", canvasWidth/2, canvasHeight/2);
                 p.textAlign(p.LEFT, p.TOP); // Reset alignment
            }
        }

        p.draw = function() {
            if (!active && currentTurn === -1) { 
                drawStatic(); // Show initial play message
                return;
            }
            if (!active && currentTurn > -1) {
                drawStatic(); // Show current state of conversation statically
                return;
            }
            // If active, proceed with typing animation
            p.background(230, 235, 240); 
            p.textSize(canvasHeight * 0.065);
            
            if (active && currentTurn >= 0 && currentTurn < dialogue.length) {
                if (p.frameCount % 4 === 0 && charIndex < dialogue[currentTurn].text.length) { // Slower typing
                    charIndex++;
                    typedText = dialogue[currentTurn].text.substring(0, charIndex);
                } else if (charIndex >= dialogue[currentTurn].text.length) {
                    active = false; // Current turn's typing finished
                    // No p.noLoop() here, drawStatic will handle it or nextTurn will re-activate
                }
            }
            drawStatic(); // Redraw the whole conversation with the currently typing text
        };
        
        p.nextTurn = function() {
            if (charIndex < (dialogue[currentTurn]?.text.length || 0) && currentTurn !== -1) {
                // If current turn is still typing, finish it instantly
                charIndex = dialogue[currentTurn].text.length;
                typedText = dialogue[currentTurn].text;
                active = false; 
                drawStatic(); // Redraw with finished text
                return; // Wait for another click for the next actual turn
            }

            if (currentTurn < dialogue.length - 1) {
                currentTurn++;
                typedText = "";
                charIndex = 0;
                active = true;
                p.loop(); // Ensure animation loop is running for typing
            } else { 
                currentTurn = -1; // Reset conversation
                typedText = "";
                charIndex = 0;
                active = false; 
                drawStatic(); // Redraw initial state or final state
            }
        };
    };
    let p5_dialogue;


    // Initialize sketches and connect buttons
    // Ensure this runs after the DOM is fully loaded
    function initializeAnimations() {
        // Check if containers exist before creating sketches
        if (document.getElementById('armVsDiffusionCanvasContainer')) {
            p5_armVsDiffusion = new p5(armVsDiffusionSketch);
            document.getElementById('playArmVsDiffusion').onclick = function() {
                if(p5_armVsDiffusion) p5_armVsDiffusion.startAnimation();
            }
        }

        if (document.getElementById('maskingPredictionCanvasContainer')) {
            p5_maskingPrediction = new p5(maskingPredictionSketch);
            document.getElementById('playMaskingPrediction').onclick = function() {
                 if(p5_maskingPrediction) p5_maskingPrediction.startAnimation();
            }
        }
        
        if (document.getElementById('scalabilityCanvasContainer')) {
            p5_scalability = new p5(scalabilitySketch);
            document.getElementById('playScalability').onclick = function() {
                if(p5_scalability) p5_scalability.startAnimation();
            }
        }

        if (document.getElementById('reversalCurseCanvasContainer')) {
            p5_reversalCurse = new p5(reversalCurseSketch);
            document.getElementById('playReversalCurse').onclick = function() {
                if(p5_reversalCurse) p5_reversalCurse.startAnimation();
            }
        }
        
        if (document.getElementById('dialogueAnimationCanvasContainer')) {
            p5_dialogue = new p5(dialogueSketch);
            document.getElementById('playDialogue').onclick = function() {
                if(p5_dialogue) p5_dialogue.nextTurn();
            }
        }
    }

    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initializeAnimations);
    } else {
        initializeAnimations(); // DOMContentLoaded has already fired
    }

    </script>
</body>
</html>